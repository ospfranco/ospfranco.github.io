<head>
  <link rel="preconnect" href="https://rsms.me/" />
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="utf-8" />
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="/assets/favicon.ico"
  />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Custom Rust errors with context and location | Oscar Franco</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Custom Rust errors with context and location" />
<meta name="author" content="Oscar Franco" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve had an issue with Rust errors for a while. They don’t come with a lot of context information, this paired with the plentiful usage of the ? operator, sometimes leaves you scratching your head where and how was an error thrown. I just came across rust errors without dependencies. Where the author describes how to get Rust errors with context and location. While it does solve the issue I explored the same problem some months ago and came with a different solution." />
<meta property="og:description" content="I’ve had an issue with Rust errors for a while. They don’t come with a lot of context information, this paired with the plentiful usage of the ? operator, sometimes leaves you scratching your head where and how was an error thrown. I just came across rust errors without dependencies. Where the author describes how to get Rust errors with context and location. While it does solve the issue I explored the same problem some months ago and came with a different solution." />
<link rel="canonical" href="https://ospfranco.com/custom-rust-errors-with-context-and-location/" />
<meta property="og:url" content="https://ospfranco.com/custom-rust-errors-with-context-and-location/" />
<meta property="og:site_name" content="Oscar Franco" />
<meta property="og:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-12-29T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="twitter:title" content="Custom Rust errors with context and location" />
<meta name="twitter:site" content="@ospfranco" />
<meta name="twitter:creator" content="@Oscar Franco" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Oscar Franco"},"dateModified":"2025-12-29T00:00:00-04:00","datePublished":"2025-12-29T00:00:00-04:00","description":"I’ve had an issue with Rust errors for a while. They don’t come with a lot of context information, this paired with the plentiful usage of the ? operator, sometimes leaves you scratching your head where and how was an error thrown. I just came across rust errors without dependencies. Where the author describes how to get Rust errors with context and location. While it does solve the issue I explored the same problem some months ago and came with a different solution.","headline":"Custom Rust errors with context and location","image":"https://ospfranco.com/assets/oscar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://ospfranco.com/custom-rust-errors-with-context-and-location/"},"url":"https://ospfranco.com/custom-rust-errors-with-context-and-location/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/css/site.css" />
</head>

<html>
  <header class="w-full flex flex-col items-center justify-center pt-12 pb-4">
  <!-- <img src="/assets/bg.png" class="" /> -->
  <div class="w-full max-w-4xl flex items-center gap-2 px-4">
    <a href="/" class="flex-1 flex items-center text-black dark:text-white">
      <img src="/assets/oscar.jpg" class="w-8 h-8 rounded-xl mr-2 object-cover" />
      Oscar Franco</a>

    <!-- <div class="h-2 w-2 rounded-full bg-green-400 animate-pulse"></div>
    <a href="mailto:ospfranco@gmail.com"
    target="_blank" class="text-sm">
      Available for freelance work
    </a> -->
  </div>
</header>

<body class="flex flex-col items-center">
  <div class="px-4 pt-8 min-h-screen xl:max-w-4xl w-full">
    <div class="xl:mx-auto flex flex-col">
      <h1 class="text-black dark:text-white text-lg font-semibold sm:text-4xl">
        Custom Rust errors with context and location
      </h1>

      <p class="mt-2 text-neutral-500 text-sm">
        December 2025
      </p>

      <div class="pt-4 pb-20 markdown text-justify"><p>I’ve had an issue with Rust errors for a while. They don’t come with a lot of context information, this paired with the plentiful usage of the <code>?</code> operator, sometimes leaves you scratching your head where and how was an error thrown. I just came across <a href="https://vincents.dev/blog/rust-errors-without-dependencies/">rust errors without dependencies</a>. Where the author describes how to get Rust errors with context and location. While it does solve the issue I explored the same problem some months ago and came with a different solution.</p>

<p>My main issue with some of the existing solutions is the need to manually call <code>.map_err</code> whenever you have a function that might throw an error. In a large enough codebase, it is a huge amount of boiler-plate. In a world of LLMs this might not be an issue for you, but I hate (most) of what LLMs produce and I review code line by line, so this approach is not really a solution for me.</p>

<p>Here are the constraints I wanted:</p>

<ul>
  <li>Ability to add a custom context message to the error (e.g “cannot parse ‘3^’”)</li>
  <li>Try to avoid manually mapping errors as much as possible or when desired (i.e. no <code>map_err</code> everywhere)</li>
  <li>Ability to attach location if needed without expensive stack traces. Believe me, adding stack traces can be REALLY expensive.</li>
  <li>Leverage existing libraries for all the nice features. I don’t care having to use external crates, they actually make life easier.</li>
</ul>

<p>So here is the solution I came up with using thiserror and a macro:</p>

<pre><code class="language-rust">#[derive(Debug, thiserror::Error, Clone, Serialize)]
pub struct MyError {
    pub error: Error,
    pub file: String,
    pub line: String,
}

impl std::fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "{} (at {}:{})", self.error, self.file, self.line)
    }
}


#[derive(Debug, thiserror::Error, Clone, Serialize)]
pub enum Error {
    #[error("Unknown Error: {0}")]
    Unknown(String),
    #[error("Api Error. {0} - {1}")]
    ApiErr(String, String),
    #[error("Invalid API Key")]
    InvalidApiKey,
    // ... All the other error types you want
}

impl From&lt;Error&gt; for MyError {
    fn from(error: Error) -&gt; Self {
        MyError {
            error,
            file: String::new(),
            line: String::new(),
        }
    }
}

pub type Result&lt;T&gt; = std::result::Result&lt;T, MyError&gt;;

#[macro_export]
macro_rules! wherr {
    ($err:expr) =&gt; {{
        let file = file!().to_string();
        let line = line!().to_string();
        $crate::error::MyError {
            error: $err,
            file,
            line,
        }
    }};
}

// An example cohercion from a external lib error to the custom error
impl From&lt;reqwest::Error&gt; for MyError {
    fn from(error: reqwest::Error) -&gt; Self {
        let status = error
            .status()
            .map_or_else(|| "No HTTP Status".to_string(), |s| s.to_string());

        let mut details = vec![error.to_string()];

        if let Some(url) = error.url() {
            details.push(format!("URL: {url}"));
        }

        if error.is_timeout() {
            details.push("Request timed out".to_string());
        }

        if error.is_connect() {
            details.push("Connection failed".to_string());
        }

        if error.is_request() {
            details.push("Invalid request".to_string());
        }

        MyError {
            error: Error::ApiErr(status, details.join(" | ")),
            file: file!().to_string(),
            line: line!().to_string(),
        }
    }
}
</code></pre>

<h2 id="castingreturning-other-lib-errors">Casting/Returning other lib errors</h2>

<p>I can easily just use the <code>?</code> operator on a function call to a lib, sometimes the location information can be derived:</p>

<pre><code class="language-rust">// Sample dummy http function
pub async fn do_http_request() -&gt; Result&lt;()&gt; {
    let client = reqwest::Client::builder().build().unwrap();
    let res = client.post("https://blah.com/ping").await?;
}
</code></pre>

<p>I can also return errors without line information:</p>

<pre><code class="language-rust">  return Err(Error::Unknown("Could not do very important operation"));
</code></pre>

<p>If I do care about the line information, I can either use <code>map_err</code> or depending on the code directly use the <code>wherr!</code> macro:</p>

<pre><code class="language-rust">// When mapping external library errors
let response = client
let client = reqwest::Client::builder().build().unwrap();
let res = client
    .post("https://blah.com/ping")?;
    .map_err(|e| {
        wherr!(Error::ApiErr(
            format!("{:?}", e.status()),
            format!("Could not ping backend, check your network, error: {e}"),
        ))
    })?;
    
// When mapping a internal error
if response.status() != 200 {
    let err = wherr!(Error::ApiErr(
        format!("{:?}", response.status()),
        "Failed to perform health check".to_string(),
    ));

    return Err(err);
}
</code></pre>

<p>When the error is returned/printed it should contain the line information plus the context defined by <code>this:error</code>. At least to me it’s a bit more idiomatic than wrapping errors everywhere.</p>
</div>
    </div>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>
  </div>
</body>
</html>
