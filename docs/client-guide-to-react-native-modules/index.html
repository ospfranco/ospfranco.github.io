<head>
  <link rel="preconnect" href="https://rsms.me/" />
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="utf-8" />
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="/assets/favicon.ico"
  />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Client guide to React Native modules | Oscar Franco</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Client guide to React Native modules" />
<meta name="author" content="Oscar Franco" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="You are my client. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI, Turbo Module and new arch stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article." />
<meta property="og:description" content="You are my client. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI, Turbo Module and new arch stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article." />
<link rel="canonical" href="https://ospfranco.com/client-guide-to-react-native-modules/" />
<meta property="og:url" content="https://ospfranco.com/client-guide-to-react-native-modules/" />
<meta property="og:site_name" content="Oscar Franco" />
<meta property="og:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-06-25T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="twitter:title" content="Client guide to React Native modules" />
<meta name="twitter:site" content="@ospfranco" />
<meta name="twitter:creator" content="@Oscar Franco" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Oscar Franco"},"dateModified":"2024-06-25T00:00:00+02:00","datePublished":"2024-06-25T00:00:00+02:00","description":"You are my client. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI, Turbo Module and new arch stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article.","headline":"Client guide to React Native modules","image":"https://ospfranco.com/assets/oscar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://ospfranco.com/client-guide-to-react-native-modules/"},"url":"https://ospfranco.com/client-guide-to-react-native-modules/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/css/site.css" />
</head>

<html>
  <header class="w-full flex flex-col items-center justify-center pt-12 pb-4">
  <!-- <img src="/assets/bg.png" class="" /> -->
  <div class="w-full max-w-4xl flex items-center gap-2 px-4">
    <a href="/" class="flex-1 flex items-center text-black dark:text-white">
      <img src="/assets/oscar.jpg" class="w-8 h-8 rounded-xl mr-2 object-cover" />
      Oscar Franco</a>

    <!-- <div class="h-2 w-2 rounded-full bg-green-400 animate-pulse"></div>
    <a href="mailto:ospfranco@gmail.com"
    target="_blank" class="text-sm">
      Available for freelance work
    </a> -->
  </div>
</header>

<body class="flex flex-col items-center">
  <div class="px-4 pt-8 min-h-screen xl:max-w-4xl w-full">
    <div class="xl:mx-auto flex flex-col">
      <h1 class="text-black dark:text-white text-lg font-semibold sm:text-4xl">
        Client guide to React Native modules
      </h1>

      <p class="mt-2 text-neutral-500 text-sm">
        June 2024
      </p>

      <div class="pt-4 pb-20 markdown text-justify"><p>You are my client. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI, Turbo Module and new arch stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article.</p>

<h1 id="old-arch">Old arch</h1>

<p>The old arch is dead. Finito. But it was just a way to serialize data via JSON and pass it between JS and the native runtimes.</p>

<h1 id="new-arch-or-now-the-arch">New arch (or now, the arch)</h1>

<p>React Native used to have a bad reputation for having bad performance. In order to solve this, one of the key problems was the JSON communication. So a bunch of concepts/modules/ideas were introduced. The conjunction of the JSI, Fabric and Turbo Modules form what is called <code class="language-plaintext highlighter-rouge">new arch</code></p>

<h2 id="jsi">JSI</h2>

<p>The first thing to solve is the slow passing data between JS and native. To fix this, the JavaScript Interface = <code class="language-plaintext highlighter-rouge">JSI</code> was introduced. It’s basically a bunch of C++ functions that allow to interact with JavaScript from C++ without paying for serialization costs of JSON. You can think of it as Node-API (NodeJS protocol to call native code) but a bit slower/custom, since it’s not a binary communication protocol but rather a bolt-on. JSI is not exclusive to RN but needs to be implemented per engine.</p>

<p>The problem when interacting with C++ code though is that it there is a non-abstracted gap between the runtime behavior of the JS engine and your code. Your JS code runs on a JS engine (JSC or Hermes in React Native’s case), but actually one should think about this JS “context” as a virtual machine. It’s a VM that can be instantiated multiple times (though your UI will run on just one of them) which is a trick used to achieve “parallelism” in JS. Each VM/engine instace reads your JS and internal state, has it’s own heap and can die out. Most importantly, you cannot just fiddle with it while is interpreting your JS. The functions provided by <code class="language-plaintext highlighter-rouge">JSI</code>, allow to do work with this virtual machine/context/runtime by allowing to enqueue callbacks, cast JS values into C++ values, etc.</p>

<p><code class="language-plaintext highlighter-rouge">JSI</code> is the corner stone of the new arch.</p>

<h2 id="fabric">Fabric</h2>

<p>Forget about fabric, it’s about how UI components are rendered using the <code class="language-plaintext highlighter-rouge">JSI</code> and it’s mostly internal. It will have very little influence on your module, with the exception on how your UI components are registered.</p>

<h1 id="turbo-modules">Turbo Modules</h1>

<p>Turbo Modules are how we create JSI enabled native modules. Turbo Modules are <strong>built</strong> on top of <code class="language-plaintext highlighter-rouge">JSI</code>. You can have <code class="language-plaintext highlighter-rouge">new arch</code> modules (that use the JSI) without Turbo Modules, but not the other way around. <code class="language-plaintext highlighter-rouge">Turbo Modules</code> take a Typescript or Flow file, and then generate a bunch of C++ code, which React Native then includes in your project. They allow for lazy initialization of modules which makes your app start faster. There are many drawbacks though. The codegen system is finicky at best, it has already had many breaking changes between versions. Documentation is scant and confusing.</p>

<h1 id="expo-modules">Expo Modules</h1>

<p><code class="language-plaintext highlighter-rouge">Turbo Modules</code> and the necessary knowledge to make use of the <code class="language-plaintext highlighter-rouge">JSI</code> is not trivial. It requires C++, ObjC, Kotlin/Java, Java’s JNI, build systems and some of the internals of RN. The guys at expo saw from a mile away that for a team building an app in React Native, it is pretty much an impossible task to learn how to code all of these by themselves. Therefore they baked their own module system into the Expo framework.</p>

<p>They require much less boilerplate. Expo itself holds the necessary code to initialize and run the modules so the code you write is pretty minimal. They do not contain any codegen step so that’s a bit of a drawback, but given the frequency to which codegeneration fails, it can actually be a good thing. Expo really tried to make the DX of them as easy as posible.</p>

<p>They do have a drawback though, compared to TurboModules they are slow. Compared to Nitro Modules and raw C++ JSI modules they are way way slower. They are good enough for the general use case and expo themselves use their bindings for their native code so it’s GOOD ENOUGH for the general use case but if performance is your #1 priority, you probably should not use them.</p>

<h1 id="jsi-c-modules">JSI C++ Modules</h1>

<p>It’s notable to mention that there are a lot of cases where you don’t want to interact with the native languages (Swift/Kotlin) but you might want to do pure C++ bindings. For some libraries like <code class="language-plaintext highlighter-rouge">sqlite</code>, <code class="language-plaintext highlighter-rouge">libsql</code>, Rust modules, some C library you CAN write a pure C++ module that does not go through the Turbo Module sub system. This will be the fastest option in terms of runtime cost, but documentation is super scant, outdated. They are also tricky to setup. [op-sqlite] is an example of a library written in (mostly) pure C++. But even though they are super difficult to setup they will almost never break (with the exception of the initialization which requires a stub Turbo Module) because you are directly interacting with the raw C++ code.</p>

<h1 id="nitro-modules">Nitro Modules</h1>

<p>Nitro Modules were created by Marc Rousavy. Him being a master of raw JSI C++ coding, started abstracting away many of the patterns in pure C++ code to make it easier to create modules. They are faster than either Turbo or Expo Modules. However, it is yet a third-party system supported by a smaller organization (or rather individual) and they do have their own quirks. With regards to speed they are probably on par with pure JSI C++ Modules but they do allow to call Swift/Kotlin far far more easier without the necessity of a lot of hand typed boilerplate. They have their own code generator but seems to work more reliably than the Turbo Modules one.</p>

<h1 id="node-api-modules">Node API Modules</h1>

<p>The most experimental of the libraries. Allows to create RN modules using Nodes NAPI interface. The benefits are quite clear, you now can use any module existing for node-js inside of RN. I don’t know if they are faster than turbo modules or JSI C++ Modules as they are still experimental and require the upmost latest versions of Hermes to work. The upsides are huge but only time will tell if they gain mainstream adoption. In theory they should allow you to test your native modules in a Node environment plugin a huge gap with the introduction of the JSI which is not being able to test your custom native modules without the whole of a React Native runtime environment.</p>

<h1 id="which-should-you-pick">Which should you pick?</h1>

<p>It depends.</p>

<p>You want to just call some Swift/Kotlin, already on Expo and are ok with their performance: Expo Modules</p>

<p>Require the most amount of performance and have extensive C++/Java/Android/ObjC/iOS knowledge: JSI C++ Modules</p>

<p>Require the best performance but afraid of native monsters and ok with the risk of smaller third party module system: Nitro Modules</p>

<p>If you want most of the perfomance without expo or third party packages: Turbo Modules</p>

<p>Risky but with node compatibility: NAPI Modules</p>

<h1 id="qa">QA</h1>

<p><strong>Is it possible to have a <code class="language-plaintext highlighter-rouge">new arch</code> (i.e. Turbo Module) that is compatible with <code class="language-plaintext highlighter-rouge">old arch</code>?</strong></p>

<p>The old arch is gone.</p>

<p><strong>Do you like Turbo Modules?</strong></p>

<p>I don’t, they are tricky to setup, but most importantly codegen has been very brittle.</p>

<p><strong>But Expo [insert your comment here]</strong></p>

<p>Expo Modules are great if they work for you. For further questions go ask the Expo team.</p>

<p><strong>You say <code class="language-plaintext highlighter-rouge">JSI</code> is C++, how come <code class="language-plaintext highlighter-rouge">Turbo Modules</code> are ObjC/Kotlin/Java?</strong></p>

<p>The same way Expo Modules are Swift/Kotlin. Jumping between languages. Swift → ObjC++ → C++. Kotlin/Java → <code class="language-plaintext highlighter-rouge">JNI</code> (which is SLOW) → C++. Your simple returning functions require a lot of casting stuff all the way to the right C++ abstractions.</p>

<p><strong>Can I write my Turbo Module in Swift?</strong></p>

<p>No… kinda… The latest versions of Swift (5.9+) improved compatibility with C++. Nitro Modules took advantage of this compatibility layer but neither Turbo or Expo Modules take advantage of this (yet) as it is not mature enough.</p>

<p><strong>When will I be able to write my <code class="language-plaintext highlighter-rouge">Turbo Module</code> in Swift?</strong></p>

<p>Don’t know, go ask Meta very nicely to do this.</p>

<p><strong>Can I write a native module in Rust?</strong></p>

<p>Yes, but not directly. Your Rust code needs to expose a C-ABI compatible API, which will then be called from a C++ turbo module, <a href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/">here is a guide</a> there are guides in this website and some other packages, but again, smaller orgs/teams, you can take the risk.</p>

<p><strong>What are the pitfalls when writing my native module?</strong></p>

<p>There are many, for example you cannot just invoke a JSI/JS function in the middle of your native code. The JS VM might be busy doing something else, if you all of the sudden ask it to allocate memory for a JS object for example, you might corrupt the stack and your entire thing will go kaput. In order to get this you need to schedule a callback using a call invoker, then await on your native code, etc etc. The different modules systems protect you against this, but there is so many details there that you might face dragons every once in a while.</p>

</div>
    </div>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>
  </div>
</body>
</html>
