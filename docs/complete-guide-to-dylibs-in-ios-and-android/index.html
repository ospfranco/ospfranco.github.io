<head>
  <link rel="preconnect" href="https://rsms.me/" />
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="utf-8" />
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="/assets/favicon.ico"
  />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Complete guide to (Rust) dylibs in iOS and Android | Oscar Franco</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Complete guide to (Rust) dylibs in iOS and Android" />
<meta name="author" content="Oscar Franco" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In 2025 setting loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps." />
<meta property="og:description" content="In 2025 setting loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps." />
<link rel="canonical" href="https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/" />
<meta property="og:url" content="https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/" />
<meta property="og:site_name" content="Oscar Franco" />
<meta property="og:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-30T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="twitter:title" content="Complete guide to (Rust) dylibs in iOS and Android" />
<meta name="twitter:site" content="@ospfranco" />
<meta name="twitter:creator" content="@Oscar Franco" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Oscar Franco"},"dateModified":"2025-07-30T00:00:00+02:00","datePublished":"2025-07-30T00:00:00+02:00","description":"In 2025 setting loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps.","headline":"Complete guide to (Rust) dylibs in iOS and Android","image":"https://ospfranco.com/assets/oscar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/"},"url":"https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/css/site.css" />
</head>

<html>
  <header class="w-full flex flex-col items-center justify-center pt-12 pb-4">
  <!-- <img src="/assets/bg.png" class="" /> -->
  <div class="w-full max-w-4xl flex items-center gap-2 px-4">
    <a href="/" class="flex-1 flex items-center text-black dark:text-white">
      <img src="/assets/oscar.jpg" class="w-8 h-8 rounded-xl mr-2 object-cover" />
      Oscar Franco</a>

    <!-- <div class="h-2 w-2 rounded-full bg-green-400 animate-pulse"></div>
    <a href="mailto:ospfranco@gmail.com"
    target="_blank" class="text-sm">
      Available for freelance work
    </a> -->
  </div>
</header>

<body class="flex flex-col items-center">
  <div class="px-4 pt-8 min-h-screen xl:max-w-4xl w-full">
    <div class="xl:mx-auto flex flex-col">
      <h1 class="text-black dark:text-white text-lg font-semibold sm:text-4xl">
        Complete guide to (Rust) dylibs in iOS and Android
      </h1>

      <p class="mt-2 text-neutral-500 text-sm">
        July 2025
      </p>

      <div class="pt-4 pb-20 markdown"><p>In 2025 setting loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps.</p>

<p>This is a complete guide compiling a Rust library from source all the way into loading it in a running iOS/Android application. All done via C binary, which means on iOS you will need to call if from Obj-C and on Android via JNI.</p>

<h1 id="dylib">Dylib?</h1>

<p>First a dylib is great, because unlike a static library, it doesn’t package the whole world when it comes to the code it needs to run. In my project on iOS the resulting binary went from 32Mbs to 10Mbs on iOS and from 57Mbs to 13Mbs(!) on Android. You can read more on why static linking is, although a very functional solution, <a href="https://medium.com/@eyal.itkin/the-a-file-is-a-relic-why-static-archives-were-a-bad-idea-all-along-8cd1cf6310c5">kinda sucks</a>.</p>

<h1 id="rust">Rust</h1>

<p>We will start with a Rust crate and we will generate a dylib out of it.</p>

<p>Init a basic create with the –lib template. You can then expose a C function that you will be able to call from your iOS Obj-C/Kotlin via JNI code.</p>

<pre><code class="language-rust">// lib.rs
#[no_mangle]
pub extern "C" fn get_answer() -&gt; i32 {
  42
}
</code></pre>

<p>Next on the <code>Cargo.toml</code>, we will declare the crate type as <code>cdylib</code>. the <code>cdylib</code> assumes that libc will be available on the target you are compiling to, so it will produce even smaller binaries. We will also add some flags to the release compilation profile to generate even smaller binaries:</p>

<pre><code class="language-toml">[profile.release]
strip = "symbols"
lto = true
opt-level = "z"
codegen-units = 1

[lib]
crate-type = ["cdylib"]
</code></pre>

<p>Now, you will need to compile your crate for both iOS and Android. For iOS is mostly straight forward since you are compiling on a Mac (you need a mac anyways to compile iOS apps):</p>

<pre><code class="language-bash">cargo build --lib --release --target aarch64-apple-ios
</code></pre>

<p>For Android one needs to set up a lot of variables pointing to the correct android libraries, headers and compilers. It’s all a PITA to be honest, so we are not going to bother with that, and instead rely on <code>cargo-ndk</code> a package that handles the correct paths for us. Read the <a href="https://github.com/bbqsrc/cargo-ndk">README</a>, set up the necessary variables and you should be able to do:</p>

<pre><code class="language-bash">cargo ndk --target aarch64-linux-android --platform=31 build --lib
</code></pre>

<p>That’s the simple version of it. As your library grows and depends on other compilation steps you will need to modify your commands accordingly. Maybe setting a sysroot. Passing header files, setting up compiler files, etc.</p>

<p>If you compile your crate in your <code>target/{arch}</code> directories you should find a <code>.dylib</code> for iOS and a <code>.so</code> for Android. Going to skip some steps here for the sake of brevity, buy you should set <code>cbindgen</code> in your project along with a <code>build.rs</code> that generates a header file <code>.h</code> for your crates C (<code>lib.rs</code>) functions.</p>

<p>You will need to compile this binary for all the architectures your app supports, typical for mobiles will be:</p>

<p><code>aarch64-apple-ios</code>
<code>aarch64-apple-ios-sim</code>
<code>x86_64-apple-ios-sim</code>
<code>aarch64-linux-android</code>
<code>armv7-linux-androideabi</code>
<code>x86_64-linux-android</code>
<code>i686-linux-android</code></p>

<p>That’s it for the native side of things, even if you are using other language like C, once you have those files correctly compiled plus your header file, it’s time to move to the OS specific setup.</p>

<h1 id="ios">iOS</h1>

<p>Going to start with iOS as it is the most PITA out of the platforms. There is very little information out on how to load dylibs, not only that, unlike macOS and other unix derivations, it is not possible to just load them but they need to be packaged in a <code>.xcframework</code> that contains several <code>.framework</code>s… it’s confusing and unnecessary.</p>

<p><a href="https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/">This part is taken from a previous article about package dylibs for iOS</a></p>

<ol>
  <li>Once these files are generated we need to merge the arm-simulator and intel-simulator binaries into a single “fat” binary. The reason is clashing of architectures (both arm-sim and intel-sim target the same “arch” so they clash and need to be merged into a “fat” binary). iOS dylibs <strong>HAVE NO EXTENSION</strong>.</li>
</ol>

<pre><code class="language-bash"># Where ${profile} is the profile you are compiling
lipo -create target/x86_64-apple-ios/${profile}/mylib.dylib target/aarch64-apple-ios-sim/${profile}/mylib.dylib -output generated/simulator_fat/mylib
</code></pre>

<ol>
  <li>With the binary merged we can drop everything into a <code>.xcframework</code> template. <a href="https://github.com/OP-Engineering/op-sqlite/tree/main/ios/sqlitevec.xcframework">You can download it here</a>. You need of course rename it properly and modify the paths but by using a template we skip more not-so-important steps.
Copy the fat binary you just created into the <code>mylib.xcframework/ios-arm64_x86_64-simulator/mylib.framework</code> (after you have renamed the folders ofc, mylib is just a placeholder). Copy the <code>aarch64-apple-sim</code> version to the correct folder as well:</li>
</ol>

<pre><code class="language-bash">cp generated/simulator_fat/mylib mylib.xcframework/ios-arm64_x86_64-simulator/mylib.framework/
cp target/aarch64-apple-ios/${profile}/mylib.dylib mylib.xcframework/ios-arm64/mylib.framework/mylib
</code></pre>

<ol>
  <li>With the files in the correct places we need to final set the <code>@rpath</code>. The runtime path (@rpath) basically tells the OS where to find the canonical path of the file. It’s mean for the runtime linker to find the correct file from a memory safe location when the app is compiled in hardened mode. This is confusing, don’t think too much about it, it has to do with sand-boxing and security of the OS.</li>
</ol>

<h2 id="xcframework">XCFramework</h2>

<p>After you got your library compiled correctly, it’s not enough to just drop them somewhere on iOS and call it a day. The <code>.xcframework</code> which basically is a folder that contains an <code>Info.plist</code>, tells Xcode/iOS which framework to load based on your computer arch and target. The <code>Info.plist</code> also contains entries to the folders which contain the <code>frameworks</code> that actually contain the dylibs.</p>

<h2 id="each-framework-infoplist">Each framework Info.plist</h2>

<p>Each <code>.framework</code> inside the <code>.xcframework</code> contains it’s own <code>Info.plist</code>. You can ignore most of this except the <code>CFBundleIdentifier</code> and <code>CFBundleExecutable</code>. These are important because they will be used on runtime to load the binary. You should modify them to match your library name and bundle identifier, modify both <code>Info.plist</code> files in the <code>.framework</code> folders:</p>

<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
  &lt;string&gt;en&lt;/string&gt;
  &lt;key&gt;CFBundleExecutable&lt;/key&gt;
  &lt;string&gt;mylib&lt;/string&gt; // MODIFY THIS
  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
  &lt;string&gt;com.ospfranco.mylib&lt;/string&gt; // MODIFY THIS
  &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
  &lt;string&gt;6.0&lt;/string&gt;
  &lt;key&gt;CFBundlePackageType&lt;/key&gt;
  &lt;string&gt;FMWK&lt;/string&gt;
  &lt;key&gt;CFBundleSignature&lt;/key&gt;
  &lt;string&gt;????&lt;/string&gt;
  &lt;key&gt;CFBundleVersion&lt;/key&gt;
  &lt;string&gt;1.0.0&lt;/string&gt;
  &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
  &lt;string&gt;1.0.0&lt;/string&gt;
	&lt;key&gt;MinimumOSVersion&lt;/key&gt;
  &lt;string&gt;8.0&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<h2 id="including-the-files-in-the-build">Including the files in the build</h2>

<p>Here things will change a bit if you are directly adding the <code>.xcframework</code> into your project or if you are creating a library via cocoapods or SPM. In any case, you need to add your <code>mylib.h</code> header file (generated via <code>build.rs</code> and <code>cbindgen</code> remember?) and the <code>.xcframework</code> with the binaries.</p>

<h3 id="directly-into-project">Directly into project</h3>

<p>If you are integrating this dylib directly into your project. You can just drop the header file somewhere and import it directly in your <code>obj-c</code> code. The <code>.xcframework</code> you also add via Xcode UI and then add it as a dependency it via the UI in the general tab of your main target.</p>

<h3 id="via-cocoapods">Via Cocoapods</h3>

<p>If you are using cocoapods you need to drop the header file and modify the paths cocoapods uses to include headers into the Pods, as well as specifying the <code>.xcframework</code>, in my case, I created a <code>include</code> folder in my source folder and dropped the header there:</p>

<pre><code class="language-ruby">  # In the .podspec of your library
  s.public_header_files = 'include/**/*.h', 'src/objc/*.h'
  s.source_files = 'src/**/*', 'include/**/*.h'
  s.vendored_frameworks = 'mylib.xcframework'

  # Configure for dynamic library
  s.pod_target_xcconfig = {
    'OTHER_LDFLAGS' =&gt; '-undefined dynamic_lookup'
  }
</code></pre>

<p>Ignore the <code>OTHER_LDFLAGS</code> we will come back to them later.</p>

<h3 id="via-spm">Via SPM</h3>

<p>In SPM is a bit more obscure so something like this should work in your <code>Package.swift</code>:</p>

<pre><code class="language-swift"> targets: [
    .binaryTarget(
      name: "mylib",
      path: "mylib.xcframework"
    ),
    .target(
      name: "MyWrapperLib",
      dependencies: ["mylib"],
      path: "src/objc",
      publicHeadersPath: ".",
      cSettings: [
        .headerSearchPath("../../include")
      ],
    ),
</code></pre>

<h2 id="loading-the-dylib">Loading the dylib</h2>

<p>Let’s assume we are using Cocoapods. After doing a <code>pod install</code> the <code>.xcframework</code> should be included in our app, as well as our header file. In your Obj-C code you should be able to import the header file:</p>

<pre><code class="language-objc">#import "mylib.h"
#import &lt;dlfcn.h&gt; // contains dlopen to load the dylib
</code></pre>

<p>But despite including the header file, it does not mean our library is loaded into the runtime. We need to use the <code>dlopen</code> function to do this. <code>dlopen</code> comes from the ancient times of unix, which basically tells iOS to load a dylib. Place this wherever you want to load your dylib:</p>

<pre><code class="language-obj-c">  force_symbol_registration();

  NSBundle *dylib_bundle =
      [NSBundle bundleWithIdentifier:@"com.ospfranco.mylib"];
  NSString *dylib_path = [dylib_bundle pathForResource:@"mylib" ofType:@""];

  // Load the dynamic library
  void *handle = dlopen([dylib_path UTF8String], RTLD_NOW | RTLD_GLOBAL);
  if (!handle) {
    NSString *errorMessage = [NSString stringWithUTF8String:dlerror()];
  }
</code></pre>

<p>Broken down:</p>

<ul>
  <li>dylib_bundle and dylib_path gets the runtime path of the appropriate binary for our arch. This is why we needed to set @rpath and modify the Info.plist in the <code>.framework</code> files</li>
  <li>We then call <code>dlopen</code> to load the library</li>
  <li>The <code>force_symbol_registration()</code> and <code>RTDL_GLOBAL</code> give the loaded library access to the global symbol table. Meaning your library can call C functions exposed by your iOS code. We will come back to this later.</li>
</ul>

<p>In theory that’s it, you should now be able to call the <code>get_answer</code> function from your Rust dylib!</p>

<pre><code class="language-obj-c">#import "mylib.h"
#import &lt;dlfcn.h&gt;

// ...main()
{
  force_symbol_registration();

  NSBundle *dylib_bundle =
      [NSBundle bundleWithIdentifier:@"com.ospfranco.mylib"];
  NSString *dylib_path = [dylib_bundle pathForResource:@"mylib" ofType:@""];

  // Load the dynamic library
  void *handle = dlopen([dylib_path UTF8String], RTLD_NOW | RTLD_GLOBAL);
  if (!handle) {
    NSString *errorMessage = [NSString stringWithUTF8String:dlerror()];
  }

  int the_answer = get_answer();
}

</code></pre>

<h1 id="android">Android</h1>

<p>Android luckily is basically just linux underneath, it’s just <code>CMakeList</code> that is ancient technology and one needs to correct arcane commands to load a dylib.</p>

<h2 id="place-the-files-in-the-correct-place">Place the files in the correct place</h2>

<p>I’m going to skip certain parts as this post is long enough, but you basically need to drop the <code>.so</code> files you generated into <code>src/main/jniLibs</code> on per architecture folders if you are doing this as a library or <code>app/src/main/jniLibs</code> if doing it directly into your app. The header file you can drop in <code>src/main/jni/include</code> or <code>app/src/main/jni/include</code> respectively.</p>

<pre><code>src
  main
    jni
      include
        mylib.h
    jniLibs
      arm64-v8a
        mylib.so
      armeabi-v7a
        mylib.so
      x86
        mylib.so
      x86_64
        mylib.so
</code></pre>

<p>The <code>jniLibs</code> folder is special and will be automatically picked up by Android in the compilation of the application. You can then follow any tutorial to set up JNI C++ code in your app/library. The only important point is linking our binary to the lib/app C++ code.</p>

<h2 id="making-cmake-load-the-so">Making CMake load the .so</h2>

<p>In <code>CMakeLists.txt</code>:</p>

<pre><code>cmake_minimum_required(VERSION 3.22.1)

project("MyJNIProject")

add_library(${CMAKE_PROJECT_NAME} SHARED
    MyJNIProject.cpp)

target_include_directories(${CMAKE_PROJECT_NAME} PUBLIC ${CMAKE_SOURCE_DIR}/../jni/include)

# Import the shared library but don't embed the absolute path
add_library(mylib SHARED IMPORTED)
set_target_properties(mylib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/mylib.so
    IMPORTED_NO_SONAME ON)

target_link_libraries(${CMAKE_PROJECT_NAME}
    mylib
    android)
</code></pre>

<p>Then in your Java/Kotlin code you just load the library created by CMakeLists which will in turn already have the <code>mylib.so</code> linked internally:</p>

<pre><code class="language-kotlin">    init {
        System.loadLibrary("MyJNIProject")
    }
</code></pre>

<h2 id="calling-the-code-from-jni-code">Calling the code from JNI code</h2>

<p>On your C++/JNI code you can just import the headers and call the functions you need</p>

<pre><code class="language-C++">#include "mylib.h"

void main() {
  int the_answer = get_answer()
}
</code></pre>

<h1 id="make-native-symbols-available-to-dylib">Make native symbols available to Dylib</h1>

<p>Here is a kicker. In the code above there have been some lines of code we have been omitting explaining what they do. Basically, without them, you can load your dylib and call it’s functions, but your dylib cannot call functions in your app’s code. This is particularly useful if you want to access some native functionality. You can write a extern “C” function that wraps some native iOS/Android api and call that from your Rust code.</p>

<h2 id="ios-1">iOS</h2>

<p>Let’s define some C function:</p>

<pre><code class="language-obj-c">// in the header file
OBJC_EXTERN void ios_prepare_request(const char *url);
</code></pre>

<p>The definition:</p>

<pre><code class="language-obj-c">#define EXPORT __attribute__((visibility("default"), used)

EXPORT void ios_prepare_request(const char *url) {
  NSString *urlString = [NSString stringWithUTF8String:url];
  request =
      [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];
}
</code></pre>

<p>In our Rust code, for iOS one can have in one (cfg’ed) file:</p>

<pre><code class="language-rust">unsafe extern "C" {
    fn ios_prepare_request(url: *const c_char);
}
</code></pre>

<p>For android the equivalent:</p>

<pre><code class="language-rust">unsafe extern "C" {
    fn android_prepare_request(url: *const c_char);
}

</code></pre>

<p>You can see this is super useful to expose functionality to our Rust code. In order to expose global symbols when using <code>dlopen</code> one passes the <code>RTDL_GLOBAL</code> flag:</p>

<pre><code class="language-obj-c">void *handle = dlopen([dylib_path UTF8String], RTLD_NOW | RTLD_GLOBAL);
</code></pre>

<p>However, there is a problem, is that clang deletes away our function, since we are not using it in our native code, so code analysis just deletes since it cannot now that the dylib depends on that function, that’s were the <code>force_symbol_registration</code> comes into play. It forces the compiler to keep our functions alive:</p>

<pre><code class="language-obj-c">void force_symbol_registration() {
  // Force these symbols to be included in the binary by referencing them
  volatile void *ptrs[] = {(void *)ios_prepare_request};

  // Prevent compiler from optimizing away the array
  (void)ptrs;
}
</code></pre>

<h2 id="android-1">Android</h2>

<p>Android is much easier, only adding the <code>IMPORTED_NO_SONAME</code> attribute when declaring our shared library already takes care of exposing the symbols:</p>

<pre><code>set_target_properties(mylib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/mylib.so
    IMPORTED_NO_SONAME ON)
</code></pre>

<p>Whatever is declared in your C++/JNI code should be made available automatically to the Rust code.</p>

<h1 id="conclusion">Conclusion</h1>

<p>After all is done, not only have we loaded a dylib rust crate into iOS/Android, but also given the Rust code the ability to interact with native code (via wrapper C functions), which opens a world of possibilities.</p>
</div>
    </div>

    <link
      rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>
  </div>
</body>

</html>
