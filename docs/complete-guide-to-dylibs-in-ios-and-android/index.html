<head>
  <link rel="preconnect" href="https://rsms.me/" />
  <link rel="stylesheet" href="https://rsms.me/inter/inter.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="utf-8" />
  <link
    rel="shortcut icon"
    type="image/x-icon"
    href="/assets/favicon.ico"
  />
  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Complete guide to (Rust) dylibs in iOS and Android | Oscar Franco</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Complete guide to (Rust) dylibs in iOS and Android" />
<meta name="author" content="Oscar Franco" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In 2025 loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps." />
<meta property="og:description" content="In 2025 loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps." />
<link rel="canonical" href="https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/" />
<meta property="og:url" content="https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/" />
<meta property="og:site_name" content="Oscar Franco" />
<meta property="og:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-07-30T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:image" content="https://ospfranco.com/assets/oscar.jpg" />
<meta property="twitter:title" content="Complete guide to (Rust) dylibs in iOS and Android" />
<meta name="twitter:site" content="@ospfranco" />
<meta name="twitter:creator" content="@Oscar Franco" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Oscar Franco"},"dateModified":"2025-07-30T00:00:00+02:00","datePublished":"2025-07-30T00:00:00+02:00","description":"In 2025 loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps.","headline":"Complete guide to (Rust) dylibs in iOS and Android","image":"https://ospfranco.com/assets/oscar.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/"},"url":"https://ospfranco.com/complete-guide-to-dylibs-in-ios-and-android/"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/css/site.css" />
</head>

<html>
  <header class="w-full flex flex-col items-center justify-center pt-12 pb-4">
  <!-- <img src="/assets/bg.png" class="" /> -->
  <div class="w-full max-w-4xl flex items-center gap-2 px-4">
    <a href="/" class="flex-1 flex items-center text-black dark:text-white">
      <img src="/assets/oscar.jpg" class="w-8 h-8 rounded-xl mr-2 object-cover" />
      Oscar Franco</a>

    <!-- <div class="h-2 w-2 rounded-full bg-green-400 animate-pulse"></div>
    <a href="mailto:ospfranco@gmail.com"
    target="_blank" class="text-sm">
      Available for freelance work
    </a> -->
  </div>
</header>

<body class="flex flex-col items-center">
  <div class="px-4 pt-8 min-h-screen xl:max-w-4xl w-full">
    <div class="xl:mx-auto flex flex-col">
      <h1 class="text-black dark:text-white text-lg font-semibold sm:text-4xl">
        Complete guide to (Rust) dylibs in iOS and Android
      </h1>

      <p class="mt-2 text-neutral-500 text-sm">
        July 2025
      </p>

      <div class="pt-4 pb-20 markdown text-justify"><p>In 2025 loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple’s side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps.</p>

<p>This is a complete guide compiling a Rust library from source all the way into loading it in a running iOS/Android application. All done via C compatible dylib, which means on iOS you will need to call if from Obj-C and on Android via JNI.</p>

<h1 id="dylib">Dylib?</h1>

<p>First a dynamic library is great, unlike a static library, it doesn’t package the whole world when it comes to the code it needs to run. In my project, which was using static libraries, the resulting binary went from 32Mbs to 10Mbs on iOS and from 57Mbs to 13Mbs(!) on Android. You can read more on why static linking, although a very functional solution, <a href="https://medium.com/@eyal.itkin/the-a-file-is-a-relic-why-static-archives-were-a-bad-idea-all-along-8cd1cf6310c5">kinda sucks</a>.</p>

<h1 id="rust">Rust</h1>

<p>We will start with a Rust crate and we will generate a dylib out of it.</p>

<p>Init a basic create with the –lib template. You can then expose a C function that you will be able to call from your iOS Obj-C/Kotlin via JNI code.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lib.rs</span>
<span class="nd">#[no_mangle]</span>
<span class="k">pub</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="k">fn</span> <span class="nf">get_answer</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">i32</span> <span class="p">{</span>
  <span class="mi">42</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next on the <code class="language-plaintext highlighter-rouge">Cargo.toml</code>, we will declare the crate type as <code class="language-plaintext highlighter-rouge">cdylib</code>. The <code class="language-plaintext highlighter-rouge">cdylib</code> crate type assumes that libc will be available on the target you are compiling to, so it will produce even smaller binaries. We will also add some flags to the release compilation profile to generate even smaller binaries:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">[</span><span class="n">profile</span><span class="k">.</span><span class="n">release</span><span class="k">]</span>
<span class="n">strip</span> <span class="o">=</span><span class="w"> </span><span class="s">"symbols"</span>
<span class="n">lto</span> <span class="o">=</span><span class="w"> </span><span class="kc">true</span>
<span class="n">opt-level</span> <span class="o">=</span><span class="w"> </span><span class="s">"z"</span>
<span class="n">codegen-units</span> <span class="o">=</span><span class="w"> </span><span class="mi">1</span>

<span class="k">[</span><span class="n">lib</span><span class="k">]</span>
<span class="n">crate-type</span> <span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s">"cdylib"</span><span class="p">]</span>
</code></pre></div></div>

<p>Now, you will need to compile your crate for both iOS and Android. For iOS is mostly straight forward since you are compiling on a Mac (you need a mac anyways to compile iOS apps):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo build <span class="nt">--lib</span> <span class="nt">--release</span> <span class="nt">--target</span> aarch64-apple-ios
</code></pre></div></div>

<p>For Android one needs to set up a lot of variables pointing to the correct android libraries, headers and compilers. It’s all a PITA to be honest, so we are not going to bother with that, and instead rely on <code class="language-plaintext highlighter-rouge">cargo-ndk</code> a package that handles the correct paths for us. Read the <a href="https://github.com/bbqsrc/cargo-ndk">README</a>, set up the necessary variables and you should be able to do:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cargo ndk <span class="nt">--target</span> aarch64-linux-android <span class="nt">--platform</span><span class="o">=</span>31 build <span class="nt">--lib</span>
</code></pre></div></div>

<p>That’s the simple version of it. As your library grows and depends on other compilation steps you will need to modify your commands accordingly. Maybe setting a sysroot. Passing header files, setting up compiler files, etc.</p>

<p>Once compilation is done, in the <code class="language-plaintext highlighter-rouge">target/{arch}</code> directories you should find a <code class="language-plaintext highlighter-rouge">.dylib</code> for iOS and a <code class="language-plaintext highlighter-rouge">.so</code> for Android. Going to skip some steps here for the sake of brevity, buy you should set <code class="language-plaintext highlighter-rouge">cbindgen</code> in your project along with a <code class="language-plaintext highlighter-rouge">build.rs</code> that generates a header file <code class="language-plaintext highlighter-rouge">.h</code> for your crates C (<code class="language-plaintext highlighter-rouge">lib.rs</code>) functions.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="k">crate</span> <span class="n">cbindgen</span><span class="p">;</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">env</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">generate_c_headers</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">crate_dir</span> <span class="o">=</span> <span class="nn">env</span><span class="p">::</span><span class="nf">var</span><span class="p">(</span><span class="s">"CARGO_MANIFEST_DIR"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">header_path</span> <span class="o">=</span> <span class="s">"../generated/include/mylib.h"</span><span class="p">;</span>

    <span class="nn">cbindgen</span><span class="p">::</span><span class="nn">Builder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
        <span class="nf">.with_crate</span><span class="p">(</span><span class="n">crate_dir</span><span class="p">)</span>
        <span class="nf">.with_language</span><span class="p">(</span><span class="nn">cbindgen</span><span class="p">::</span><span class="nn">Language</span><span class="p">::</span><span class="n">C</span><span class="p">)</span>
        <span class="nf">.with_autogen_warning</span><span class="p">(</span>
            <span class="s">"/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nf">.generate</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Unable to generate bindings"</span><span class="p">)</span>
        <span class="nf">.write_to_file</span><span class="p">(</span><span class="n">header_path</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Tell Cargo that if the given file changes, to rerun this build script.</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rerun-if-changed=src/lib.rs"</span><span class="p">);</span>

    <span class="c1">// Tell cargo to dynamically link the C function we defined</span>
    <span class="c1">// We will come back to this later</span>
    <span class="k">let</span> <span class="n">target_os</span> <span class="o">=</span> <span class="nn">env</span><span class="p">::</span><span class="nf">var</span><span class="p">(</span><span class="s">"CARGO_CFG_TARGET_OS"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="k">match</span> <span class="n">target_os</span><span class="nf">.as_str</span><span class="p">()</span> <span class="p">{</span>
        <span class="s">"ios"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-arg=-undefined"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-arg=dynamic_lookup"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="s">"android"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-arg=-Wl,--allow-shlib-undefined"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="nf">generate_c_headers</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>

<p>You will need to compile this binary for all the architectures your app supports, typical for mobiles will be:</p>

<p><code class="language-plaintext highlighter-rouge">aarch64-apple-ios</code>
<code class="language-plaintext highlighter-rouge">aarch64-apple-ios-sim</code>
<code class="language-plaintext highlighter-rouge">x86_64-apple-ios-sim</code>
<code class="language-plaintext highlighter-rouge">aarch64-linux-android</code>
<code class="language-plaintext highlighter-rouge">armv7-linux-androideabi</code>
<code class="language-plaintext highlighter-rouge">x86_64-linux-android</code>
<code class="language-plaintext highlighter-rouge">i686-linux-android</code></p>

<p>That’s it for the native side of things, even if you are using other language like C, once you have those files correctly compiled plus your header file, it’s time to move to the OS specific setup.</p>

<h1 id="ios">iOS</h1>

<p>Going to start with iOS as it is the most PITA out of the platforms. There is very little information out on how to load dylibs, not only that, unlike macOS and other unix derivations, it is not possible to just load them but they need to be packaged in a <code class="language-plaintext highlighter-rouge">.xcframework</code> that contains several <code class="language-plaintext highlighter-rouge">.framework</code>s… it’s confusing and unnecessary.</p>

<p><a href="https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/">This part is taken from a previous article about package dylibs for iOS</a></p>

<ol>
  <li>Once these files are generated we need to merge the arm-simulator and intel-simulator binaries into a single “fat” binary. The reason is clashing of architectures (both arm-sim and intel-sim target the same “arch” so they clash and need to be merged into a “fat” binary). iOS dylibs <strong>HAVE NO EXTENSION</strong>.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Where ${profile} is the profile you are compiling</span>
lipo <span class="nt">-create</span> target/x86_64-apple-ios/<span class="k">${</span><span class="nv">profile</span><span class="k">}</span>/mylib.dylib target/aarch64-apple-ios-sim/<span class="k">${</span><span class="nv">profile</span><span class="k">}</span>/mylib.dylib <span class="nt">-output</span> generated/simulator_fat/mylib
</code></pre></div></div>

<ol>
  <li>With the binary merged we can drop everything into a <code class="language-plaintext highlighter-rouge">.xcframework</code> template. <a href="https://github.com/OP-Engineering/op-sqlite/tree/main/ios/sqlitevec.xcframework">You can download it here</a>. You need of course rename it properly and modify the paths but by using a template we skip more not-so-important steps.
Copy the fat binary you just created into the <code class="language-plaintext highlighter-rouge">mylib.xcframework/ios-arm64_x86_64-simulator/mylib.framework</code> (after you have renamed the folders ofc, mylib is just a placeholder). Copy the <code class="language-plaintext highlighter-rouge">aarch64-apple-sim</code> version to the correct folder as well:</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>generated/simulator_fat/mylib mylib.xcframework/ios-arm64_x86_64-simulator/mylib.framework/
<span class="nb">cp </span>target/aarch64-apple-ios/<span class="k">${</span><span class="nv">profile</span><span class="k">}</span>/mylib.dylib mylib.xcframework/ios-arm64/mylib.framework/mylib
</code></pre></div></div>

<ol>
  <li>With the files in the correct places we need to final set the <code class="language-plaintext highlighter-rouge">@rpath</code>. The runtime path basically tells the OS where to find the canonical path of the file. It’s mean for the runtime linker to find the correct file from a memory safe location when the app is compiled in hardened mode. This is confusing, don’t think too much about it, it has to do with sand-boxing and security of the OS.</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>install_name_tool <span class="nt">-id</span> @rpath/mylib.framework/mylib mylib.xcframework/ios-arm64_x86_64-simulator/sdk.framework/mylib
install_name_tool <span class="nt">-id</span> @rpath/mylib.framework/mylib mylib.xcframework/ios-arm64/sdk.framework/mylib
</code></pre></div></div>

<h2 id="xcframework">XCFramework</h2>

<p>After you got your library compiled correctly, it’s not enough to just drop them somewhere on iOS and call it a day. The <code class="language-plaintext highlighter-rouge">.xcframework</code> which basically is a folder that contains an <code class="language-plaintext highlighter-rouge">Info.plist</code>, tells Xcode/iOS which framework to load based on your computer arch and target. The <code class="language-plaintext highlighter-rouge">Info.plist</code> also contains entries to the folders which contain the <code class="language-plaintext highlighter-rouge">frameworks</code> that actually contain the dylibs.</p>

<h2 id="each-framework-infoplist">Each framework Info.plist</h2>

<p>Each <code class="language-plaintext highlighter-rouge">.framework</code> inside the <code class="language-plaintext highlighter-rouge">.xcframework</code> contains it’s own <code class="language-plaintext highlighter-rouge">Info.plist</code>. You can ignore most of this except the <code class="language-plaintext highlighter-rouge">CFBundleIdentifier</code> and <code class="language-plaintext highlighter-rouge">CFBundleExecutable</code>. These are important because they will be used on runtime to load the binary. You should modify them to match your library name and bundle identifier, modify both <code class="language-plaintext highlighter-rouge">Info.plist</code> files in the <code class="language-plaintext highlighter-rouge">.framework</code> folders:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="cp">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span>
<span class="nt">&lt;plist</span> <span class="na">version=</span><span class="s">"1.0"</span><span class="nt">&gt;</span>
<span class="nt">&lt;dict&gt;</span>
  <span class="nt">&lt;key&gt;</span>CFBundleDevelopmentRegion<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>en<span class="nt">&lt;/string&gt;</span>
  <span class="nt">&lt;key&gt;</span>CFBundleExecutable<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>mylib<span class="nt">&lt;/string&gt;</span> // MODIFY THIS
  <span class="nt">&lt;key&gt;</span>CFBundleIdentifier<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>com.ospfranco.mylib<span class="nt">&lt;/string&gt;</span> // MODIFY THIS
  <span class="nt">&lt;key&gt;</span>CFBundleInfoDictionaryVersion<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>6.0<span class="nt">&lt;/string&gt;</span>
  <span class="nt">&lt;key&gt;</span>CFBundlePackageType<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>FMWK<span class="nt">&lt;/string&gt;</span>
  <span class="nt">&lt;key&gt;</span>CFBundleSignature<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>????<span class="nt">&lt;/string&gt;</span>
  <span class="nt">&lt;key&gt;</span>CFBundleVersion<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>1.0.0<span class="nt">&lt;/string&gt;</span>
  <span class="nt">&lt;key&gt;</span>CFBundleShortVersionString<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>1.0.0<span class="nt">&lt;/string&gt;</span>
	<span class="nt">&lt;key&gt;</span>MinimumOSVersion<span class="nt">&lt;/key&gt;</span>
  <span class="nt">&lt;string&gt;</span>8.0<span class="nt">&lt;/string&gt;</span>
<span class="nt">&lt;/dict&gt;</span>
<span class="nt">&lt;/plist&gt;</span>
</code></pre></div></div>

<h2 id="including-the-files-in-the-build">Including the files in the build</h2>

<p>Here things will change a bit if you are directly adding the <code class="language-plaintext highlighter-rouge">.xcframework</code> into your project or if you are creating a library via cocoapods or SPM. In any case, you need to add your <code class="language-plaintext highlighter-rouge">mylib.h</code> header file (generated via <code class="language-plaintext highlighter-rouge">build.rs</code> and <code class="language-plaintext highlighter-rouge">cbindgen</code> remember?) and the <code class="language-plaintext highlighter-rouge">.xcframework</code> with the binaries.</p>

<h3 id="directly-into-project">Directly into project</h3>

<p>If you are integrating this dylib directly into your project. You can just drop the header file somewhere and import it directly in your <code class="language-plaintext highlighter-rouge">obj-c</code> code. The <code class="language-plaintext highlighter-rouge">.xcframework</code> you also add via Xcode UI and then add it as a dependency it via the UI in the general tab of your main target.</p>

<h3 id="via-cocoapods">Via Cocoapods</h3>

<p>If you are using cocoapods you need to drop the header file and modify the paths cocoapods uses to include headers into the Pods, as well as specifying the <code class="language-plaintext highlighter-rouge">.xcframework</code>, in my case, I created a <code class="language-plaintext highlighter-rouge">include</code> folder in my source folder and dropped the header there:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># In the .podspec of your library</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">public_header_files</span> <span class="o">=</span> <span class="s1">'include/**/*.h'</span><span class="p">,</span> <span class="s1">'src/objc/*.h'</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">source_files</span> <span class="o">=</span> <span class="s1">'src/**/*'</span><span class="p">,</span> <span class="s1">'include/**/*.h'</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">vendored_frameworks</span> <span class="o">=</span> <span class="s1">'mylib.xcframework'</span>

  <span class="c1"># Configure for dynamic library</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">pod_target_xcconfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'OTHER_LDFLAGS'</span> <span class="o">=&gt;</span> <span class="s1">'-undefined dynamic_lookup'</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Ignore the <code class="language-plaintext highlighter-rouge">OTHER_LDFLAGS</code> we will come back to them later.</p>

<h3 id="via-spm">Via SPM</h3>

<p>In SPM is a bit more obscure so something like this should work in your <code class="language-plaintext highlighter-rouge">Package.swift</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">targets</span><span class="p">:</span> <span class="p">[</span>
    <span class="o">.</span><span class="nf">binaryTarget</span><span class="p">(</span>
      <span class="nv">name</span><span class="p">:</span> <span class="s">"mylib"</span><span class="p">,</span>
      <span class="nv">path</span><span class="p">:</span> <span class="s">"mylib.xcframework"</span>
    <span class="p">),</span>
    <span class="o">.</span><span class="nf">target</span><span class="p">(</span>
      <span class="nv">name</span><span class="p">:</span> <span class="s">"MyWrapperLib"</span><span class="p">,</span>
      <span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="s">"mylib"</span><span class="p">],</span>
      <span class="nv">path</span><span class="p">:</span> <span class="s">"src/objc"</span><span class="p">,</span>
      <span class="nv">publicHeadersPath</span><span class="p">:</span> <span class="s">"."</span><span class="p">,</span>
      <span class="nv">cSettings</span><span class="p">:</span> <span class="p">[</span>
        <span class="o">.</span><span class="nf">headerSearchPath</span><span class="p">(</span><span class="s">"../../include"</span><span class="p">)</span>
      <span class="p">],</span>
    <span class="p">),</span>
</code></pre></div></div>

<h2 id="loading-the-dylib">Loading the dylib</h2>

<p>Let’s assume we are using Cocoapods. After doing a <code class="language-plaintext highlighter-rouge">pod install</code> the <code class="language-plaintext highlighter-rouge">.xcframework</code> should be included in our app, as well as our header file. In your Obj-C code you should be able to import the header file:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "mylib.h"
#import &lt;dlfcn.h&gt; // contains dlopen to load the dylib
</span></code></pre></div></div>

<p>But despite including the header file, it does not mean our library is loaded into the runtime. We need to use the <code class="language-plaintext highlighter-rouge">dlopen</code> function to do this. <code class="language-plaintext highlighter-rouge">dlopen</code> comes from the ancient times of unix, which basically tells iOS to load a dylib. Place this wherever you want to load your dylib:</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">force_symbol_registration</span><span class="p">();</span>

  <span class="n">NSBundle</span> <span class="o">*</span><span class="n">dylib_bundle</span> <span class="o">=</span>
      <span class="p">[</span><span class="n">NSBundle</span> <span class="nf">bundleWithIdentifier</span><span class="p">:</span><span class="s">@"com.ospfranco.mylib"</span><span class="p">];</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">dylib_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">dylib_bundle</span> <span class="nf">pathForResource</span><span class="p">:</span><span class="s">@"mylib"</span> <span class="nf">ofType</span><span class="p">:</span><span class="s">@""</span><span class="p">];</span>

  <span class="c1">// Load the dynamic library</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">([</span><span class="n">dylib_path</span> <span class="nf">UTF8String</span><span class="p">],</span> <span class="n">RTLD_NOW</span> <span class="o">|</span> <span class="n">RTLD_GLOBAL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">errorMessage</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithUTF8String</span><span class="p">:</span><span class="n">dlerror</span><span class="p">()];</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>Broken down:</p>

<ul>
  <li>dylib_bundle and dylib_path gets the runtime path of the appropriate binary for our arch. This is why we needed to set @rpath and modify the Info.plist in the <code class="language-plaintext highlighter-rouge">.framework</code> files</li>
  <li>We then call <code class="language-plaintext highlighter-rouge">dlopen</code> to load the library</li>
  <li>The <code class="language-plaintext highlighter-rouge">force_symbol_registration()</code> and <code class="language-plaintext highlighter-rouge">RTDL_GLOBAL</code> give the loaded library access to the global symbol table. Meaning your library can call C functions exposed by your iOS code. We will come back to this later.</li>
</ul>

<p>In theory that’s it, you should now be able to call the <code class="language-plaintext highlighter-rouge">get_answer</code> function from your Rust dylib!</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#import "mylib.h"
#import &lt;dlfcn.h&gt;
</span>
<span class="c1">// ...main()</span>
<span class="p">{</span>
  <span class="n">force_symbol_registration</span><span class="p">();</span>

  <span class="n">NSBundle</span> <span class="o">*</span><span class="n">dylib_bundle</span> <span class="o">=</span>
      <span class="p">[</span><span class="n">NSBundle</span> <span class="nf">bundleWithIdentifier</span><span class="p">:</span><span class="s">@"com.ospfranco.mylib"</span><span class="p">];</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">dylib_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">dylib_bundle</span> <span class="nf">pathForResource</span><span class="p">:</span><span class="s">@"mylib"</span> <span class="nf">ofType</span><span class="p">:</span><span class="s">@""</span><span class="p">];</span>

  <span class="c1">// Load the dynamic library</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">([</span><span class="n">dylib_path</span> <span class="nf">UTF8String</span><span class="p">],</span> <span class="n">RTLD_NOW</span> <span class="o">|</span> <span class="n">RTLD_GLOBAL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">errorMessage</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithUTF8String</span><span class="p">:</span><span class="n">dlerror</span><span class="p">()];</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">the_answer</span> <span class="o">=</span> <span class="n">get_answer</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>

<h1 id="android">Android</h1>

<p>Android luckily is basically just linux underneath, it’s just <code class="language-plaintext highlighter-rouge">CMakeList</code> that is ancient technology and one needs to correct arcane commands to load a dylib.</p>

<h2 id="place-the-files-in-the-correct-place">Place the files in the correct place</h2>

<p>I’m going to skip certain parts as this post is long enough, but you basically need to drop the <code class="language-plaintext highlighter-rouge">.so</code> files you generated into <code class="language-plaintext highlighter-rouge">src/main/jniLibs</code> on per architecture folders if you are doing this as a library or <code class="language-plaintext highlighter-rouge">app/src/main/jniLibs</code> if doing it directly into your app. The header file you can drop in <code class="language-plaintext highlighter-rouge">src/main/jni/include</code> or <code class="language-plaintext highlighter-rouge">app/src/main/jni/include</code> respectively.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src
  main
    jni
      include
        mylib.h
    jniLibs
      arm64-v8a
        mylib.so
      armeabi-v7a
        mylib.so
      x86
        mylib.so
      x86_64
        mylib.so
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">jniLibs</code> folder is special and will be automatically picked up by Android in the compilation of the application. You can then follow any tutorial to set up JNI C++ code in your app/library. The only important point is linking our binary to the lib/app C++ code.</p>

<h2 id="making-cmake-load-the-so">Making CMake load the .so</h2>

<p>In <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.22.1)

project("MyJNIProject")

add_library(${CMAKE_PROJECT_NAME} SHARED
    MyJNIProject.cpp)

target_include_directories(${CMAKE_PROJECT_NAME} PUBLIC ${CMAKE_SOURCE_DIR}/../jni/include)

# Import the shared library but don't embed the absolute path
add_library(mylib SHARED IMPORTED)
set_target_properties(mylib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/mylib.so
    IMPORTED_NO_SONAME ON)

target_link_libraries(${CMAKE_PROJECT_NAME}
    mylib
    android)
</code></pre></div></div>

<p>Then in your Java/Kotlin code you just load the library created by CMakeLists which will in turn already have the <code class="language-plaintext highlighter-rouge">mylib.so</code> linked internally:</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nf">init</span> <span class="p">{</span>
        <span class="nc">System</span><span class="p">.</span><span class="nf">loadLibrary</span><span class="p">(</span><span class="s">"MyJNIProject"</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="calling-the-code-from-jni-code">Calling the code from JNI code</h2>

<p>On your C++/JNI code you can just import the headers and call the functions you need</p>

<pre><code class="language-C++">#include "mylib.h"

void main() {
  int the_answer = get_answer()
}
</code></pre>

<h1 id="make-native-symbols-available-to-dylib">Make native symbols available to Dylib</h1>

<p>Here is a kicker. In the code above there have been some lines of code we have been omitting explaining what they do. Basically, without them, you can load your dylib and call it’s functions, but your dylib cannot call functions in your app’s code. This is particularly useful if you want to access some native functionality. You can write a extern “C” function that wraps some native iOS/Android api and call that from your Rust code.</p>

<h2 id="rust-1">Rust</h2>

<p>In rust we already added some <code class="language-plaintext highlighter-rouge">rustc</code> linker flags via <code class="language-plaintext highlighter-rouge">build.rs</code> that basically tell the Rust compiler to not panic if it cannot find a symbol. Since we are creating a dylib. The symbols will be there on runtime</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">match</span> <span class="n">target_os</span><span class="nf">.as_str</span><span class="p">()</span> <span class="p">{</span>
        <span class="s">"ios"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-arg=-undefined"</span><span class="p">);</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-arg=dynamic_lookup"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="s">"android"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"cargo:rustc-link-arg=-Wl,--allow-shlib-undefined"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{}</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="ios-1">iOS</h2>

<p>Let’s define some C function:</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in the header file</span>
<span class="n">OBJC_EXTERN</span> <span class="kt">void</span> <span class="nf">ios_prepare_request</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">);</span>
</code></pre></div></div>

<p>The definition:</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EXPORT __attribute__((visibility("default"), used)
</span>
<span class="n">EXPORT</span> <span class="kt">void</span> <span class="nf">ios_prepare_request</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">urlString</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithUTF8String</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
  <span class="n">request</span> <span class="o">=</span>
      <span class="p">[</span><span class="n">NSMutableURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="n">urlString</span><span class="p">]];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In our Rust code, for iOS one can have in one (cfg’ed) file:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">ios_prepare_request</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">c_char</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For android the equivalent:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">unsafe</span> <span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">android_prepare_request</span><span class="p">(</span><span class="n">url</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">c_char</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>You can see this is super useful to expose functionality to our Rust code. In order to expose global symbols when using <code class="language-plaintext highlighter-rouge">dlopen</code> one passes the <code class="language-plaintext highlighter-rouge">RTDL_GLOBAL</code> flag:</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">([</span><span class="n">dylib_path</span> <span class="nf">UTF8String</span><span class="p">],</span> <span class="n">RTLD_NOW</span> <span class="o">|</span> <span class="n">RTLD_GLOBAL</span><span class="p">);</span>
</code></pre></div></div>

<p>However, there is a problem, is that clang deletes away our function, since we are not using it in our native code, so code analysis just deletes since it cannot now that the dylib depends on that function, that’s were the <code class="language-plaintext highlighter-rouge">force_symbol_registration</code> comes into play. It forces the compiler to keep our functions alive:</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">force_symbol_registration</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Force these symbols to be included in the binary by referencing them</span>
  <span class="k">volatile</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ios_prepare_request</span><span class="p">};</span>

  <span class="c1">// Prevent compiler from optimizing away the array</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">ptrs</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="android-1">Android</h2>

<p>Android is much easier, only adding the <code class="language-plaintext highlighter-rouge">IMPORTED_NO_SONAME</code> attribute when declaring our shared library already takes care of exposing the symbols:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set_target_properties(mylib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/mylib.so
    IMPORTED_NO_SONAME ON)
</code></pre></div></div>

<p>Whatever is declared in your C++/JNI code should be made available automatically to the Rust code.</p>

<h1 id="conclusion">Conclusion</h1>

<p>After all is done, not only have we loaded a dylib rust crate into iOS/Android, but also given the Rust code the ability to interact with native code (via wrapper C functions), which opens a world of possibilities.</p>
</div>
    </div>

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <script>
      hljs.highlightAll();
    </script>
  </div>
</body>
</html>
