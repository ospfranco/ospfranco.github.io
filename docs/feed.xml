<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ospfranco.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ospfranco.com/" rel="alternate" type="text/html" /><updated>2025-01-03T08:11:36+01:00</updated><id>https://ospfranco.com/feed.xml</id><title type="html">Oscar Franco</title><author><name>Oscar Franco</name></author><entry><title type="html">Use React as a Rendering Layer</title><link href="https://ospfranco.com/use-react-as-a-rendering-layer/" rel="alternate" type="text/html" title="Use React as a Rendering Layer" /><published>2024-11-11T00:00:00+01:00</published><updated>2024-11-11T00:00:00+01:00</updated><id>https://ospfranco.com/use%20react%20as%20a%20rendering%20layer</id><content type="html" xml:base="https://ospfranco.com/use-react-as-a-rendering-layer/"><![CDATA[<p>A couple of tweets caught my eye this week:</p>

<p>[Kitze tweet]</p>

<p>[Tweet about dan leaving twitter]</p>

<p>I have tweeted extensively in the past how React state management is too complex and easy to get wrong. The fact that one has to read long threads of tweets to getting some amount of understanding of how to operate it just speaks volumes.</p>

<h1 id="render-cycles-is-a-bad-state-update-mechanism">Render cycles is a bad state update mechanism</h1>

<p>At the core of the problem lies the fact that React is a UI library. Being a UI library it first concern was to render state efficiently. To render state efficiently it came up to render cycles. Change your state, your component re-renders itself (and its children). As the library matured, we‚Äôve migrated from classes to hooks. It‚Äôs hard to decompose the problem, but it boils down to state-updates now ticks at the rythm of the render cycles:</p>

<ul>
  <li>Render</li>
  <li>Update variable</li>
  <li>Trigger re-render</li>
  <li>Trigger useEffect</li>
  <li>Potentially update variable</li>
  <li>Trigger re-render</li>
</ul>

<p>We have fallen in this cycle, where every variable change (state update) is now thought in terms of React renders. And this is a hard, complex and non-sensical way of programming. Because, everything depends on everything. It quickly explodes in complexity. You have to prevent re-renders (useMemo), try to avoid function re-creation (useCallback) while at the same time triggering side-effecty code (useEffect). This also triggers re-renderings on large parts of the UI as the prop comparisson is naive. Comically enough, React doesn‚Äôt properly react to changes, at least not smart enough. The so-called React compiler is an implicit acceptance that this model is fundamentally broken and we know need to statically analyse code to get untangle this mess.</p>

<h1 id="way-out">Way out</h1>

<p>I could ramble more and more but there is no point. If you live through the pain of maintaining a mid to large React app with lots of hooks and contexts this problem is self evident. So here is one way out: use mobx.</p>

<p>Mobx bring sanity to state management by using a simple observer pattern. You modify a variable, things that use the variable get re-rendered. As simple as that. Not even entire trees of things get re-render, JUST THE THINGS THAT USE IT. This means no more <code>useMemo</code>.</p>

<p>You can declare model classes once, this contains variables (<code>useState</code>), functions declared once (meaning no more <code>useCallback</code>) and calculated values. Side-effects are no longer a weird <code>useEffect</code> with a list of variables that might affect it, code can just be triggered when variables are set. Some times it might be a more code duplication, but it‚Äôs no longer React programming, it‚Äôs just programming.</p>

<p>It has some quirks, like having to use <code>runInAction</code> after using <code>await</code> but the trade-off is more than worthy. Your React code is just a rendering layer. NO HOOKS, NO CONTEXT. React excels at manipulating the DOM and giving you a re-usable abstraction, let it do just that.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[A couple of tweets caught my eye this week:]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Make MISE installed tools globally available for GUI tools</title><link href="https://ospfranco.com/make-mise-installed-tools-globally-available-for-gui-tools/" rel="alternate" type="text/html" title="Make MISE installed tools globally available for GUI tools" /><published>2024-09-23T00:00:00+02:00</published><updated>2024-09-23T00:00:00+02:00</updated><id>https://ospfranco.com/make%20mise%20installed%20tools%20globally%20available%20for%20gui%20tools</id><content type="html" xml:base="https://ospfranco.com/make-mise-installed-tools-globally-available-for-gui-tools/"><![CDATA[<p>I‚Äôm a very big fan of <a href="https://mise.jdx.dev">Mise</a>. It allows me to quickly swap and install system tools in my macOS machine. Node, Ruby, Python, JDKs, etc. Instead of doing installations that can permanently change the OS and are not easy to revert (even with Homebrew), Mise handles all multiple installations on a per folder level.</p>

<p>I usually set a global version for the most common tools I use, one of them being Node:</p>

<pre><code>mise global node@20
</code></pre>

<p>This works perfectly when I run the commands from the terminal. However, the problem comes with GUI apps such as Android Studio or Xcode. This apps do not execute binaries from a terminal session (at least not a sandboxed one). So one has to make the installed tools available to them. One way that works for single binaries (e.g. node) is to create a symlink:</p>

<pre><code>sudo ln -s $(which node) /usr/local/bin
</code></pre>

<p>However, this breaks down when one has to link a binary that might depend on a relative structure import. One example is npx:</p>

<pre><code>sudo ln -s $(which npx) /usr/local/bin
</code></pre>

<p>Will throw an error whenever the GUI program tries to execute an <code>npx</code> command. Because <code>npx</code> is just a JS script that calls <code>npm</code> internally, however it relies on a relative import:</p>

<pre><code>#!/usr/bin/env node

const cli = require('../lib/cli.js')

// run the resulting command as `npm exec ...args`
process.argv[1] = require.resolve('./npm-cli.js')
process.argv.splice(2, 0, 'exec')

// ... the rest of the npx script
</code></pre>

<h1 id="create-a-wrapper-script">Create a wrapper script</h1>

<p>In order to solve this issue, create a wrapper script in <code>/usr/local/bin</code>. The reason to place it there is because most apps default to known locations (without the chance for you to modify the PATH, e.g. Xcode).</p>

<pre><code>#!/bin/bash
# do `sudo touch npx`
NODE_BASE_DIR="/Users/osp/.local/share/mise/installs/node/20/bin"
exec "$NODE_BASE_DIR/npx" "$@"%
</code></pre>

<p>After creating it give it execute permissions:</p>

<pre><code>sudo chmod a+x /usr/local/bin/npx
</code></pre>

<p>You might need to restart your program or computer for the binary to be correctly found. This should also work for any other scripts binaries you might have an issue. If you are worried about modifying <code>/usr/local/bin</code> don‚Äôt be. It‚Äôs a per user folder where symlinks and binaries can be placed. Lots of programs add links to their binaries here to make them globally available to other GUI tools: VSCode, Parallels, etc.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I‚Äôm a very big fan of Mise. It allows me to quickly swap and install system tools in my macOS machine. Node, Ruby, Python, JDKs, etc. Instead of doing installations that can permanently change the OS and are not easy to revert (even with Homebrew), Mise handles all multiple installations on a per folder level.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Compiling OpenSSL in Rust for Android</title><link href="https://ospfranco.com/compiling-openssl-in-rust-for-android/" rel="alternate" type="text/html" title="Compiling OpenSSL in Rust for Android" /><published>2024-09-21T00:00:00+02:00</published><updated>2024-09-21T00:00:00+02:00</updated><id>https://ospfranco.com/compiling%20openssl%20in%20rust%20for%20android</id><content type="html" xml:base="https://ospfranco.com/compiling-openssl-in-rust-for-android/"><![CDATA[<p>There is now a long standing issue with the latest versions of OpenSSL. <a href="https://github.com/openssl/openssl/pull/22181">The handwritten assembly is incompatible with Position Independent Code</a>. While this issue is not resolved it means the latest versions of OpenSSL do not run on Android.</p>

<p>As a side note, the NDK port of <a href="https://github.com/android/ndk/issues/1992">OpenSSL is still on version 1.1.1 which is EOL</a>. This is a huge vunerability for Android but it seems the NDK team has no priority on updating this.</p>

<p>In a client project I‚Äôm using Rust which depends on OpenSSL. This has left me no choice other than to patch OpenSSL myself, so I get it to compile to Android platforms.</p>

<h1 id="compiling-openssl">Compiling OpenSSL</h1>

<p>Here is a script that will download and compile OpenSSL for Android directly. It already includes the patching described in the GitHub issue to patch the handcrafted assembly.</p>

<pre><code class="language-bash">#!/bin/bash

# Clone or download the sources (it's done for you at below)
# You should most definitely read the ANDROID notes to see the exact command. A lot of the scripts online are outdated for the 1.X branches
# You basically need to set the ANDROID_NDK_HOME variable for this script to work
# Generating the dylibs was failing for me, so disabled it for now

#set -v
set -ex

export OPENSSL_VERSION="openssl-3.3.2"
rm -rf ${OPENSSL_VERSION}
# Sometimes this link breaks, you can manually download the sources yourself
# curl -O "https://github.com/openssl/openssl/releases/download/${OPENSSL_VERSION}/${OPENSSL_VERSION}.tar.gz"
tar xfz "${OPENSSL_VERSION}.tar.gz"

PROJECT_HOME=`pwd`
PATH_ORG=$PATH
OUTPUT_DIR="libs"

# Clean output:
rm -rf $OUTPUT_DIR
mkdir $OUTPUT_DIR

build_android_clang() {

	echo ""
	echo "----- Build libcrypto &amp; libssl.so for "$1" -----"
	echo ""

	ARCHITECTURE=$1
	TOOLCHAIN=$2
	stl="libc++"

	# Set toolchain
	export TOOLCHAIN_ROOT=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64
	export SYSROOT=$TOOLCHAIN_ROOT/sysroot
	export CC=${TOOLCHAIN}21-clang
	export CXX=${TOOLCHAIN}21-clang++
	export CXXFLAGS="-fPIC"
	export CPPFLAGS="-DANDROID -fPIC"

	export PATH=$TOOLCHAIN_ROOT/bin:$SYSROOT/usr/local/bin:$PATH

	cd "${OPENSSL_VERSION}"

	./Configure $ARCHITECTURE no-asm no-shared -D__ANDROID_API__=21

	make clean
	# Apply patch that fixes the armcap instruction
	# Linux version
	# sed -e '/[.]hidden.*OPENSSL_armcap_P/d; /[.]extern.*OPENSSL_armcap_P/ {p; s/extern/hidden/ }' -i -- crypto/*arm*pl crypto/*/asm/*arm*pl
	# macOS version
	sed -E -i '' -e '/[.]hidden.*OPENSSL_armcap_P/d' -e '/[.]extern.*OPENSSL_armcap_P/ {p; s/extern/hidden/; }' crypto/*arm*pl crypto/*/asm/*arm*pl

	make

	mkdir -p ../$OUTPUT_DIR/${ARCHITECTURE}/lib
	mkdir -p ../$OUTPUT_DIR/${ARCHITECTURE}/include

	cp libcrypto.a ../$OUTPUT_DIR/${ARCHITECTURE}/lib/libcrypto.a
	cp libssl.a ../$OUTPUT_DIR/${ARCHITECTURE}/lib/libssl.a

	cp -R include/openssl ../$OUTPUT_DIR/${ARCHITECTURE}/include

	cd ..
}

build_android_clang "android-arm" "armv7a-linux-androideabi"
build_android_clang "android-x86" "i686-linux-android"
build_android_clang "android-x86_64" "x86_64-linux-android"
build_android_clang "android-arm64" "aarch64-linux-android"
</code></pre>

<p>This script will create a <code>libs</code> folder, which contains all the files in the necessary structure.</p>

<h1 id="compiling-rust-crate">Compiling Rust crate</h1>

<p>In order to compile this in your Rust crate you need to first add the crates:</p>

<pre><code class="language-toml">openssl = "0.10"
openssl-sys = "0.9.103"
</code></pre>

<p><code>openssl</code> is a bindings crate for the Rust code, but the openssl-sys takes care of compiling/detecting OpenSSL itself.</p>

<p>With this crates added, we can then invoke the compilation command with an added flag <code>OPENSSL_DIR</code> which <code>openssl-sys</code> will detect and instead of compiling OpenSSL from source will use the precompiled static libraries we generated.</p>

<p>Here I‚Äôm using <code>cargo-ndk</code> which is a crate that does the SDK/NDK discovery for you so you can easily compile for android. This is a <code>Makefile</code> version, but you can use whatever you want to point to it to the correct folder that matches the architecture:</p>

<pre><code class="language-make">android-build-release-%:
	@ if [ "$*" = "aarch64-linux-android" ]; then \
			OPENSSL_DIR=$(CURDIR)/libs/android-arm64; \
	  elif [ "$*" = "x86_64-linux-android" ]; then \
	    OPENSSL_DIR=$(CURDIR)/libs/android-x86_64; \
	  elif [ "$*" = "armv7-linux-androideabi" ]; then \
	    OPENSSL_DIR=$(CURDIR)/libs/android-arm; \
	  elif [ "$*" = "i686-linux-android" ]; then \
	    OPENSSL_DIR=$(CURDIR)/libs/android-x86; \
	  else \
	    echo "Unknown target: $*"; \
	    exit 1; \
	  fi; \
	  OPENSSL_DIR=$$OPENSSL_DIR cargo ndk --target $* --platform 31 build --release --all-features
</code></pre>

<p>Once everything is ready, will not only the Android binary be correct, you will actually be using the latest version of OpenSSL instead of the outdated NDK ports.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[There is now a long standing issue with the latest versions of OpenSSL. The handwritten assembly is incompatible with Position Independent Code. While this issue is not resolved it means the latest versions of OpenSSL do not run on Android.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Generating a XCFramework with dylibs for iOS</title><link href="https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/" rel="alternate" type="text/html" title="Generating a XCFramework with dylibs for iOS" /><published>2024-09-15T00:00:00+02:00</published><updated>2024-09-15T00:00:00+02:00</updated><id>https://ospfranco.com/generating%20a%20xcframework%20with%20dylibs%20for%20ios</id><content type="html" xml:base="https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/"><![CDATA[<p>This was an absolute pain to get right, so I hope I will save someone some time in case you ever need to compile a dylib for iOS.</p>

<h1 id="frameworks">Frameworks</h1>

<p>First of all, to load dylibs in iOS Apple absolutely fucked us all. You need to create a <code>.framework</code> with a lot of peculiarities. I will skip the why and most of the explanation and just give you a template you can use. These <code>framework</code>s need to be embbeded in a <code>.xcframework</code> that will load the correct version for the architecture (arm, arm-simulator, intel-simulator).</p>

<h1 id="compile-your-library">Compile your library</h1>

<p>I will take <a href="https://github.com/asg017/sqlite-vec">sqlite-vec</a> as an example. It‚Äôs a sqlite extension to do vector searching for LLMs.</p>

<p>You first need to compile your library for iOS. There are a lot of things to take care here. Detecting the correct compiler chain. You NEED to make sure you are setting the correct min iPhone OS version (dylib support was added in iOS 8). I basically take care of all of this with a Makefile:</p>

<pre><code class="language-make">MIN_IOS_VERSION = 8.0

# iOS SDK paths
IOS_SDK_PATH = $(shell xcrun --sdk iphoneos --show-sdk-path)
IOS_SIMULATOR_SDK_PATH = $(shell xcrun --sdk iphonesimulator --show-sdk-path)

# iOS cross-compiler toolchains
CC_ios_arm64 = $(shell xcrun --sdk iphoneos --find clang)
CC_ios_x86_64 = $(shell xcrun --sdk iphonesimulator --find clang)

# Output directories for iOS
OUT_DIR_ios_arm64 = dist/ios/arm64
OUT_DIR_ios_x86_64 = dist/ios/x86_64
OUT_DIR_ios_arm64_simulator = dist/ios/arm64_simulator

# iOS-specific flags
IOS_CFLAGS = -Ivendor/ -I./ -O3 -fembed-bitcode -fPIC
IOS_LDFLAGS = -Wl,-ios_version_min,$(MIN_IOS_VERSION)
IOS_ARM64_FLAGS = -target arm64-apple-ios$(MIN_IOS_VERSION) -miphoneos-version-min=$(MIN_IOS_VERSION)
IOS_ARM64_SIM_FLAGS = -target arm64-apple-ios-simulator$(MIN_IOS_VERSION) -mios-simulator-version-min=$(MIN_IOS_VERSION)
IOS_X86_64_FLAGS = -target x86_64-apple-ios-simulator$(MIN_IOS_VERSION) -mios-simulator-version-min=$(MIN_IOS_VERSION)

# Compilation rules for each iOS architecture
$(OUT_DIR_ios_arm64):
	mkdir -p $@

$(OUT_DIR_ios_x86_64):
	mkdir -p $@

$(OUT_DIR_ios_arm64_simulator):
	mkdir -p $@

# Rule for compiling for iOS arm64 (device)
ios_arm64: $(OUT_DIR_ios_arm64)
	$(CC_ios_arm64) $(CFLAGS) $(IOS_CFLAGS) $(IOS_ARM64_FLAGS) -isysroot $(IOS_SDK_PATH) -c sqlite-vec.c -o $(OUT_DIR_ios_arm64)/sqlite-vec.o
	$(CC_ios_arm64) -dynamiclib -o $(OUT_DIR_ios_arm64)/sqlitevec $(OUT_DIR_ios_arm64)/sqlite-vec.o -isysroot $(IOS_SDK_PATH) $(IOS_LDFLAGS)

# Rule for compiling for iOS x86_64 (simulator)
ios_x86_64: $(OUT_DIR_ios_x86_64)
	$(CC_ios_x86_64) $(CFLAGS) $(IOS_CFLAGS) $(IOS_X86_64_FLAGS) -isysroot $(IOS_SIMULATOR_SDK_PATH) -c sqlite-vec.c -o $(OUT_DIR_ios_x86_64)/sqlite-vec.o
	$(CC_ios_x86_64) $(IOS_X86_64_FLAGS) -dynamiclib -o $(OUT_DIR_ios_x86_64)/sqlitevec $(OUT_DIR_ios_x86_64)/sqlite-vec.o -isysroot $(IOS_SIMULATOR_SDK_PATH)

# Rule for compiling for iOS arm64 (simulator)
ios_arm64_sim: $(OUT_DIR_ios_arm64_simulator)
	$(CC_ios_arm64) $(CFLAGS) $(IOS_CFLAGS) $(IOS_ARM64_SIM_FLAGS) -isysroot $(IOS_SIMULATOR_SDK_PATH) -c sqlite-vec.c -o $(OUT_DIR_ios_arm64_simulator)/sqlite-vec.o
	$(CC_ios_arm64) -dynamiclib -o $(OUT_DIR_ios_arm64_simulator)/sqlitevec $(OUT_DIR_ios_arm64_simulator)/sqlite-vec.o -isysroot $(IOS_SIMULATOR_SDK_PATH)

# Rule to compile for all iOS architectures
ios: ios_arm64 ios_x86_64 ios_arm64_sim
  # Create a single fat for simulators
	lipo -create ./dist/ios/x86_64/sqlitevec ./dist/ios/arm64_simulator/sqlitevec -output dist/ios/sim_fat/sqlitevec

  # Move generated binary to the template xcframework folder
	cp ./dist/ios/arm64/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64/sqlitevec.framework/

  # Set @rpath
	install_name_tool -id @rpath/sqlitevec.framework/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64/sqlitevec.framework/sqlitevec

  # Move generated binary to the template xcframework folder
	cp ./dist/ios/sim_fat/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64_x86_64-simulator/sqlitevec.framework/

  # Set @rpath
	install_name_tool -id @rpath/sqlitevec.framework/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64_x86_64-simulator/sqlitevec.framework/sqlitevec

.PHONY: ios ios_arm64 ios_x86_64 ios_arm64_sim
</code></pre>

<p>That‚Äôs the full Makefile. You can see the first lines are all about the steps mentioned above. Then compiling the library into an .o and then linking it as a dylib. It creates a file without extension on each of the target architectures. This are the files we will need to package to get iOS to load the dylib.</p>

<p>Once this files are generated the makefile will try to merge the arm-simulator and intel-simulator binaries into a single ‚Äúfat‚Äù binary. The reason is clashing of architectures. This is a mandatory step to publish a single <code>.xcframework</code> that both intel and m1 machines can load.</p>

<p>The final step is adding an @rpath‚Ä¶err‚Ä¶ path to the generated binaries so that iOS can load them from a safe memory location when your app is compiled in hardened mode to be released in the app store. This is confusing, don‚Äôt think too much about it, it has to do with sandboxing and security of the OS.</p>

<h1 id="xcframework">XCFramework</h1>

<p>After you got your library compiled correctly, it‚Äôs not enough to just drop them somewhere on iOS and call it a day. In order to load all of these easily you need to package everything into a <code>.xcframework</code> which basically is a folder that contains an <code>Info.plist</code>, which tells Xcode which framework to load based on your computer arch and target. Long story short, you can just copy <a href="https://github.com/OP-Engineering/op-sqlite/tree/main/ios/sqlitevec.xcframework">this folder structure</a>. You CAN also create the <code>xcframework</code> via command, but it will not create the internal <code>frameworks</code> inside for you. Still useful command if you are compiling static libs:</p>

<pre><code class="language-sh">xcodebuild -create-xcframework -library ./sim_fat/libsqlite_vec.a -headers ../../ -library ./arm64/libsqlite_vec.a -include ../../ -output libsqlite_vec.xcframework
</code></pre>

<blockquote>
  <p>This is a sample command, won‚Äôt work for this particular dylib case. But if you just need static libs, this is it. Once you have everything packaged in an .xcframework your static libs (.a) are automatically loaded for you</p>
</blockquote>

<p>The <code>.xcframework</code> contains a <code>Info.plist</code>, inside there are entries to the folders which contain the <code>frameworks</code> that actually contain the dylibs. The makefile will combine the arm64-sim and the intel-sim binaries into a fat binary (they would clash otherwise when you try to run your app). Then try to drop them in the correct folders.</p>

<h1 id="each-framework-infoplist">Each framework Info.plist</h1>

<p>Each <code>.framework</code> inside the <code>.xcframework</code> contains it‚Äôs own <code>Info.plist</code>. You can ignore most of this except the bundle identifier. This value is important because it will be used on runtime to load the binary</p>

<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
  &lt;string&gt;en&lt;/string&gt;
  &lt;key&gt;CFBundleExecutable&lt;/key&gt;
  &lt;string&gt;sqlitevec&lt;/string&gt;
  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
  &lt;string&gt;com.ospfranco.sqlitevec&lt;/string&gt;
  &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
  &lt;string&gt;6.0&lt;/string&gt;
  &lt;key&gt;CFBundlePackageType&lt;/key&gt;
  &lt;string&gt;FMWK&lt;/string&gt;
  &lt;key&gt;CFBundleSignature&lt;/key&gt;
  &lt;string&gt;????&lt;/string&gt;
  &lt;key&gt;CFBundleVersion&lt;/key&gt;
  &lt;string&gt;1.0.0&lt;/string&gt;
  &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
  &lt;string&gt;1.0.0&lt;/string&gt;
	&lt;key&gt;MinimumOSVersion&lt;/key&gt;
  &lt;string&gt;8.0&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>You can set it to whatever you want, just remember it. Also take a look at <code>CFBundleExecutable</code> which basically tells which is the dylib that is contained in the <code>framework</code>, change it to whatever your binary is named.</p>

<h1 id="loading-it-in-runtime">Loading it in runtime</h1>

<p>After you have correctly created the <code>xcframework</code> you can then add it as a dependency in your project. Directly drop it into xcode, or if you are using cocoapods declare as:</p>

<pre><code class="language-ruby">s.vendored_frameworks = "sqlitevec.xcframework"
</code></pre>

<p>This just takes care of packaging into your app once you do <code>pod install</code>. Once the app starts you actually have load the dylib. Here is a snippet to do this:</p>

<pre><code class="language-objc">NSBundle *libsqlitevec_bundle = [NSBundle bundleWithIdentifier:@"com.ospfranco.sqlitevec"];
NSString *sqlite_vec_path = [libsqlitevec_bundle pathForResource:@"sqlitevec" ofType:@""];
</code></pre>

<p>Ok, this is not how you LOAD it, but rather how you find it in the file system. At least for my use case that is all I needed. I can then pass it to sqlite and it takes care of loading it on memory.</p>

<h1 id="debugging">Debugging</h1>

<p>If you are unsure any of the steps above is not correctly applied you can verify them.</p>

<p>Verify the min OS version is set correctly by running:</p>

<pre><code>otool -l sqlitevec.framework/sqlitevec | grep -A 3 LC_VERSION_MIN_IPHONEOS
</code></pre>

<p>If the key is there you should see the set version. This is mandatory for the iOS device arm64 version. If not set then Apple will reject your embedded framework when you send the submission to the app store. It should look something like this:</p>

<pre><code>Load command 8
      cmd LC_VERSION_MIN_IPHONEOS
  cmdsize 16
  version 8.0
      sdk 8.0
</code></pre>

<p>The last step is setting the dylib rpath (Already done in the Makefile for you):</p>

<pre><code>install_name_tool -id @rpath/sqlitevec.framework/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64_x86_64-simulator/sqlitevec.framework/sqlitevec
</code></pre>

<p>Basically @rpath is a placeholder string. It will replace it on runtime, then take the final path and try to locate your dylib. You can verify is properly set by running:</p>

<pre><code>otool -L sqlitevec.framework/sqlitevec
</code></pre>

<p>You should see an entry with <code>@rpath</code> like this:</p>

<pre><code>sqlitevec.framework/sqlitevec:
        @rpath/sqlitevec.framework/sqlitevec (compatibility version 0.0.0, current version 0.0.0)
        /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1351.0.0)
</code></pre>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[This was an absolute pain to get right, so I hope I will save someone some time in case you ever need to compile a dylib for iOS.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">App clip with React Native and New Arch (and Swift)</title><link href="https://ospfranco.com/app-clip-with-react-native-and-new-arch-(and-swift)/" rel="alternate" type="text/html" title="App clip with React Native and New Arch (and Swift)" /><published>2024-06-30T00:00:00+02:00</published><updated>2024-06-30T00:00:00+02:00</updated><id>https://ospfranco.com/app%20clip%20with%20react%20native%20and%20new%20arch%20(and%20swift)</id><content type="html" xml:base="https://ospfranco.com/app-clip-with-react-native-and-new-arch-(and-swift)/"><![CDATA[<p>I had to create an App Clip for a project using React Native. There are people who have done it before, but info is now outdated so posting an updated guide.</p>

<p>Most of the steps come from this <a href="https://github.com/codibly/app-clip-instant-app-react-native/blob/main/Creating-React-Native-AppClip.md">repo</a> kudos to codibly and also all the amazing people that provide all the packages and guides for integrations between old-arch and new-arch.</p>

<ul>
  <li>Add a new target to your project. Select Swift and StoryBoard.</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip1.jpg" alt="appclip1" /></p>

<ul>
  <li>Add the <code>@rnx-kit/react-native-host</code>. It‚Äôs a package that allows to hoist a RCTRootView in the different architectures</li>
</ul>

<pre><code class="language-sh">yarn add @rnx-kit/react-native-host --dev
</code></pre>

<ul>
  <li>Modify your <code>podfile</code></li>
</ul>

<pre><code class="language-ruby">  # In your main app target add the following

  # Auto linking is broken on this package
  # https://github.com/microsoft/rnx-kit/issues/3208
  pod 'ReactNativeHost', :path =&gt; "../node_modules/@rnx-kit/react-native-host"

  target 'Clip' do
    inherit! :complete
    # Pods for Clip
  end
</code></pre>

<ul>
  <li>Do a new arch pod install</li>
</ul>

<pre><code class="language-sh">cd ios &amp;&amp; RCT_NEW_ARCH_ENABLED=1 pod install
</code></pre>

<ul>
  <li>Create a <code>BridgeManager.swift</code> class in the Clip target. Make sure it is added to the correct target! This class will help us instantiate a ‚Äúhost‚Äù which is compatible with the old arch and new arch.</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip2.jpg" alt="appclip2" /></p>

<pre><code class="language-swift">import Foundation
import React
import ReactNativeHost

class BridgeManager: NSObject {
    static let shared = BridgeManager()

    var host: ReactNativeHost?

    public func loadReactNative(launchOptions: [AnyHashable: Any]?) {
      host = ReactNativeHost(self)
    }
}

extension BridgeManager: RNXHostConfig {
  func sourceURL(for bridge: RCTBridge) -&gt; URL? {
        #if DEBUG
          return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index.clip")
        #else
            return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
        #endif
    }
}
</code></pre>

<p>In order for the DEBUG preprocessor macro to run, we need to add the DEBUG flag into the build settings of the Clip target</p>

<p><img src="https://ospfranco.com/assets/appclip5.jpg" alt="appclip5" /></p>

<ul>
  <li>We are going to modify the <code>AppDelegate.m</code> at the Clip target:</li>
</ul>

<pre><code class="language-swift">import React
import ReactNativeHost
import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate, RNXHostConfig {

  var window: UIWindow?

  func sourceURL(for bridge: RCTBridge) -&gt; URL? {
    return nil
  }

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -&gt; Bool {
    BridgeManager.shared.loadReactNative(launchOptions: launchOptions)
    // Override point for customization after application launch.
    return true
  }

  // MARK: UISceneSession Lifecycle

  func application(
    _ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession,
    options: UIScene.ConnectionOptions
  ) -&gt; UISceneConfiguration {
    // Called when a new scene session is being created.
    // Use this method to select a configuration to create the new scene with.
    return UISceneConfiguration(
      name: "Default Configuration", sessionRole: connectingSceneSession.role)
  }

  func application(
    _ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;
  ) {
    // Called when the user discards a scene session.
    // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
    // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
  }
}
</code></pre>

<ul>
  <li>We can the finally load the <code>RCTRootView</code> (the view that holds RN) into the app clip controller</li>
</ul>

<pre><code class="language-swift">import UIKit
import ReactNativeHost

class ViewController: UIViewController {

  override func loadView() {
    if let host = BridgeManager.shared.host {
          self.view = host.view(
              moduleName: "clip",
              initialProperties: nil
          )
      }

  }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}
</code></pre>

<ul>
  <li>At this point you should get the gist of what we are trying to do. Start a RN instance inside the App Clip. However, we now need to take care of a bunch of minutia that is annoying. We are going to copy the contents of the main target <code>Bundle React Native code and images</code> but modify it so that instead of loading the <code>index.js</code> file it loads <code>index.clip.js</code>. Go to build phases, add new script and copy the contents of the script:</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip3.jpg" alt="appclip3" /></p>

<pre><code class="language-sh">set -e

WITH_ENVIRONMENT="$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh"
REACT_NATIVE_XCODE="$REACT_NATIVE_PATH/scripts/react-native-xcode.sh"

/bin/sh -c "ENTRY_FILE=index.clip.js $WITH_ENVIRONMENT $REACT_NATIVE_XCODE"
</code></pre>

<ul>
  <li>We are going to run into a hermes error. You need to disable <code>User Script Sandboxing</code> on the build settings of the clip target:</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip4.jpg" alt="appclip4" /></p>

<ul>
  <li>We can finally create our <code>index.clip.js</code> at the root of the project</li>
</ul>

<pre><code class="language-js">import React from "react";
import { AppRegistry, View, Text } from "react-native";

const AppClip = () =&gt; (
  &lt;View&gt;
    &lt;Text&gt;Hello,&lt;/Text&gt;
    &lt;Text&gt;I'm your AppClip!&lt;/Text&gt;
  &lt;/View&gt;
);

AppRegistry.registerComponent("clip", () =&gt; AppClip);
</code></pre>

<p>Notice we are registering the component as <code>clip</code> which matches the component being loaded at the ViewController.</p>

<p>That‚Äôs it, if everything is configured correctly you should be able to see your app clip loaded. You can find the repo of this app <a href="https://github.com/ospfranco/RNAppClip">here</a></p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I had to create an App Clip for a project using React Native. There are people who have done it before, but info is now outdated so posting an updated guide.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Client guide to React Native modules</title><link href="https://ospfranco.com/client-guide-to-react-native-modules/" rel="alternate" type="text/html" title="Client guide to React Native modules" /><published>2024-06-25T00:00:00+02:00</published><updated>2024-06-25T00:00:00+02:00</updated><id>https://ospfranco.com/client%20guide%20to%20react%20native%20modules</id><content type="html" xml:base="https://ospfranco.com/client-guide-to-react-native-modules/"><![CDATA[<p>Let‚Äôs play the following scenario: You are my client and I‚Äôm me. You ask ‚ÄúOscar, we want to port our SDK/Library/module to React Native, but all this <code>JSI</code>/<code>Turbo Module</code>/<code>new arch</code> stuff is confusing, can you help us?‚Äù the answer dear client is obviously yes. However, I‚Äôm a bit tired of explaining the same concepts again and again, so I will point you to this article.</p>

<blockquote>
  <p>If you are a RN dev you can skip this, this is an overview of React Native modules meant for people not in the React Native ecosystem. No new information or in-depth technical knowledge is here, just enough for adjacent people can get a grip of the terminology</p>
</blockquote>

<h1 id="old-arch">Old arch</h1>

<p>How do you pass data between JavaScript, a interpreted language that runs on C++ to native runtimes of iOS (Swift/ObjC) and Android (Java/Kotlin)? easy! JSON. You serialize your data and every native function that you need to call can pass through a narrow tube of message passing. This is what we call the <code>old arch</code> (the usage of JSON message passing is also called the <code>bridge</code>) of React Native.</p>

<h2 id="pros">Pros</h2>

<ul>
  <li>It is easy to create modules with it. Due to the ease of marking methods and the runtime registration, there is not a lot of setup necessary.</li>
  <li>‚ùó Old modules are still supported in the <code>new arch</code> (we will talk about it in a bit). In fact there has been a special work put onto them so that they remain compatible at least for extra year while libraries and apps migrate to the new arch.</li>
  <li>If your SDK sends a small amount of data, actually should be more than enough for your needs.</li>
  <li>‚≠ê If you use <code>bridgeless</code> (will talk about it in a second), they are as fast as <code>new arch</code> modules.</li>
</ul>

<h2 id="cons">Cons</h2>

<ul>
  <li>It is slow and can get stuck when there is a large amount of data being serialized between the JS code and the native runtimes.</li>
  <li>It‚Äôs being phased out</li>
</ul>

<h1 id="new-arch">New arch</h1>

<p>React Native used to have a bad reputation for having bad performance. In order to solve this, one of the key problems was the JSON bridge. So a bunch of concepts/modules/ideas where introduced. The conjunction of the following terms form what is called <code>new arch</code>:</p>

<h2 id="jsi">JSI</h2>

<p>The first thing to solve is the slow passing data between JS and native. To fix this, the JavaScript Interface = <code>JSI</code>. It‚Äôs basically a bunch of C++ functions that allow to interact with JavaScript from C++ without paying for serialization costs of JSON. You can think of it as Node-API (NodeJS protocol to call native code) but a bit shittier since it is not a binary communication protocol but rather a bolt-on with some higher costs.</p>

<p>The problem when interacting with C++ code though is that it introduces a gap between JS and native. Whenever you run JS code it runs on a JavaScript engine (JavaScript Core or Hermes in React Native‚Äôs case), but actually one should think about this ‚Äúcontext‚Äù as a virtual machine (my own words). It is a VM that can be instantiated multiple times, though your UI will run on just one of them. Multiple JS VMs are how <code>Web Workers</code> (though they are not available in RN) and certain level of parallelism in JavaScript is achieved. It reads your JS and keeps a internal state of the code it runs, has it‚Äôs own heap and can die out. Most importantly, you cannot just fiddle with it while is interpreting your JS. The functions provided by <code>JSI</code>, allow to do work with this virtual machine/context/runtime by allowing to enqueue callbacks, cast JS values into C++ values, etc.</p>

<p><code>JSI</code> is the corner stone of the new arch.</p>

<h2 id="fabric">Fabric</h2>

<p>Forget about fabric, it‚Äôs about how UI components are rendered using the <code>JSI</code> and it‚Äôs mostly internal. It will have very little influence on your module, with the exception on how your UI components are registered.</p>

<h2 id="bridgeless">Bridgeless</h2>

<p>It‚Äôs just a configuration flag that completely removes the JSON bridge. <code>old arch</code> modules will still work (in fact they will use the JSI too). It‚Äôs just part of the migration to kill the old bridge once and for all.</p>

<h1 id="turbo-modules">Turbo Modules</h1>

<p>All the internals of RN started to migrate from JSON to interacting with C++. So we now need a new way to create native modules for React Native. Turbo Modules are a solution to this problem. Is it important to know: <code>Turbo Modules</code> are <strong>built</strong> on top of <code>JSI</code>. You can have <code>new arch</code> modules (that use the JSI) without Turbo Modules, but not the other way around. <code>Turbo Modules</code> take a Typescript or Flow file, and then with a ungodly amount of JavaScript generate a bunch of C++ code, which React Native then includes in your project. They are also a DSL of TypeScript/Flow (üò•).</p>

<blockquote>
  <p><code>Turbo Modules</code> are <strong>built on top</strong> of the <code>JSI</code></p>
</blockquote>

<h2 id="pros-1">Pros</h2>

<ul>
  <li>Lazy initialization</li>
  <li>Much faster runtime performance</li>
  <li>Synchronized function definitions between JS and native</li>
</ul>

<h2 id="cons-1">Cons</h2>

<ul>
  <li>Much more harder to setup</li>
  <li>Lack of documentation</li>
  <li>Require C++ knowledge and good knowledge of the internals of RN if you deviate from the golden path</li>
</ul>

<h1 id="expo-modules">Expo modules</h1>

<p><code>Turbo Modules</code> and the necessary knowledge to make use of <code>JSI</code> is not trivial at all. It requires knowledge of C++, ObjC, Kotlin/Java, Java‚Äôs JNI, the build systems and knowledge of the internals of RN. The great guys at expo saw from a mile away that for a company/team building an app in React Native, it is pretty much an impossible task to learn how to code all of these by themselves. Therefore they also applied ungodly amounts of Kotlin/Swift magic and created their own module system.</p>

<h2 id="pros-2">Pros</h2>

<ul>
  <li>Much more easier to expose native (Swift/Kotlin) functions to JS</li>
  <li>They still use the JSI, so they are quite fast</li>
  <li>Much easier to create and move around</li>
</ul>

<h2 id="cons-2">Cons</h2>

<ul>
  <li><strong>Only run on expo apps</strong></li>
  <li>JSI is C++, Expo Modules are Swift/Kotlin, so <strong>there is</strong> a runtime performance cost. It‚Äôs not nothing, might or might not be critical depending on your module. I posted benchmarks in my Twitter.</li>
  <li>The signatures of functions need to be adjusted manually between native and the JS side</li>
</ul>

<h1 id="c-turbo-modules">C++ Turbo Modules</h1>

<p>It‚Äôs notable to mention that there are a lot of cases where you don‚Äôt want to interact with the native languages (Swift/Kotlin) but you might want to do pure C++ bindings. For some libraries like <code>sqlite</code>, <code>libsql</code>, Rust modules. This is what you want. The <code>JSI</code> is C++, your code is C(++). This will be the fastest option in terms of runtime cost, but documentation is super scant, outdated. They are also tricky to setup.</p>

<h1 id="which-should-you-pick">Which should you pick?</h1>

<p>It depends.</p>

<p>You have a small team and want to just call some native Swift/Kotlin and are running Expo already: go for Expo Modules.</p>

<p>You have a C/C++/Rust library and require the most amount of performance: Go for C++ Turbo Module or a custom JSI module.</p>

<p>You want JSI, have some expertise, not on expo: go for Turbo Modules, documentation is scant so this is the least option I recommend</p>

<p>You want to get the ball rolling for now: go for an old arch module</p>

<h1 id="qa">QA</h1>

<p><strong>Q</strong>: Is it possible to have a <code>new arch</code> (i.e. Turbo Module) that is compatible with <code>old arch</code>?</p>

<p><strong>A</strong>: Yes, but it‚Äôs terrible, it takes a lot of work, copying the generated files and modifying the compilation process so that everything runs on both archs. You will definitely need help from one of the agencies or me to get this working properly and maintain it.</p>

<p><strong>Q</strong>: Do you like Turbo Modules</p>

<p><strong>A</strong>: I don‚Äôt, they are tricky to setup with code generation step and cryptic native errors. I would much rather stick to pure C++ modules. Also, codegen sucks, never do codegen.</p>

<p><strong>Q</strong>: But Expo [insert your comment here]</p>

<p><strong>A</strong>: Expo Modules are great if they work for you. Use them. It‚Äôs fine. Go ask them for issues.</p>

<p><strong>Q</strong>: You say <code>JSI</code> is C++, how come <code>Turbo Modules</code> are ObjC/Kotlin/Java?</p>

<p><strong>A</strong>: The same way Expo Modules are Swift/Kotlin. Ungodly amount of jumping between languages. Swift ‚Üí ObjC++ ‚Üí C++. Kotlin/Java ‚Üí <code>JNI</code> (which is SLOW) ‚Üí C++. You might be returning native objects/scalars when writing your code, but there is a lot of work later to cast stuff all the way to the right C++ abstractions.</p>

<p><strong>Q</strong>: Can I write my Turbo Module in Swift?</p>

<p><strong>A</strong>: No (kinda). Latest versions of Swift (5.9+) improved compatibility with C++, but it still ways to go. The codegen scripts and all the internal tooling works with ObjC. You can write a very thin ObjC fa√ßade that will call your Swift code. So yes, there is a way to make it work but it‚Äôs not straightforward.</p>

<p><strong>Q</strong>: When will I be able to write my <code>Turbo Module</code> in Swift?</p>

<p><strong>A</strong>: Some day‚Ä¶ maybe never‚Ä¶ go ask Meta very nicely to do this :)</p>

<p><strong>Q</strong>: Can I write a native module in Rust?</p>

<p><strong>A</strong>: Yes, but not directly. Your Rust code needs to expose a C-ABI compatible API, which will then be called from a C++ turbo module, <a href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/">here is a guide</a>. There is also this <a href="https://github.com/laptou/jsi-rs">repo</a> in case you really want to write everything in rust, but I haven‚Äôt managed to get it to run, my Rust-Fu is not advanced enough, but it seems to bridge all the JSI code into Rust so you can call all the functions directly from Rust.</p>

<p><strong>Q</strong>: What are the pitfalls when writing my native module?</p>

<p><strong>A</strong>: There are many, for example you cannot just invoke a JSI/JS function in the middle of your native code. The JS VM might be busy doing something else, if you all of the sudden ask it to allocate memory for a JS object for example, you might corrupt the stack and your entire thing will go kaput. In order to get this you need to schedule a callback using a call invoker, then await on your native code, etc etc. It‚Äôs complex to get all of the moving parts working nicely.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Let‚Äôs play the following scenario: You are my client and I‚Äôm me. You ask ‚ÄúOscar, we want to port our SDK/Library/module to React Native, but all this JSI/Turbo Module/new arch stuff is confusing, can you help us?‚Äù the answer dear client is obviously yes. However, I‚Äôm a bit tired of explaining the same concepts again and again, so I will point you to this article.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Reduce Rust binaries size</title><link href="https://ospfranco.com/rust-reduce-binary-size/" rel="alternate" type="text/html" title="Reduce Rust binaries size" /><published>2024-06-23T00:00:00+02:00</published><updated>2024-06-23T00:00:00+02:00</updated><id>https://ospfranco.com/rust%20reduce%20binary%20size</id><content type="html" xml:base="https://ospfranco.com/rust-reduce-binary-size/"><![CDATA[<p>I find myself writing a lot of Rust nowadays. I‚Äôm by no means an expert, but I need to make do with my limited knowledge. A constant problem I‚Äôm facing is that the binaries outputted by Rust are huge. This is especially a problem on mobile, where each megabyte counts.</p>

<p>The documentation is a bit confusing, but here is the configuration I ended up using to get somewhat OK sizes. In the <code>cargo.toml</code> file:</p>

<pre><code class="language-toml">[profile.release] # When compiling in release mode
debug = false # Exclude debug symbols
strip = "symbols" # Exclude the rest of the symbols
# opt-level = "z" # Did not use this, but it equals C++'s optimize for size (O3?)
lto = true # Link time optimization, not sure what this does but it helps reduce the size
codegen-units = 1 # Cargo specifies 16 parallel codegen units for release builds. This improves compile times, but prevents some optimizations.
panic = "abort" # when Rust code encounters a situation when it must call panic!(), it unwinds the stack and produces a helpful backtrace. The unwinding code, however, does require extra binary size. rustc can be instructed to abort immediately rather than unwind, which removes the need for this extra unwinding code.
</code></pre>

<h1 id="cargo-bloat">Cargo Bloat</h1>

<p>I haven‚Äôt fully explored what this tool can do, but it does point to large sections of the code. Install it with <code>cargo install cargo-bloat</code> and then run:</p>

<pre><code>cargo bloat --release --target=&lt;your-target&gt;
</code></pre>

<h1 id="building-both-a-static-and-dylib">Building both a static and dylib</h1>

<p>In my experience static binaries on iOS are OK, but on Android they can be huge. Ideally you would specify <code>crate-type = ['staticlib', 'dylib']</code> and just be on your merry way, however, it seems there is a bug in the rust compiles and it bloats the static lib massively. In order to get a static binary for iOS and a dynamic one for Android you can set <code>crate-type = ['dylib']</code> and change the compilation command for iOS to <code>cargo rustc --crate-type=staticlib ...</code></p>

<h1 id="openssl">OpenSSL</h1>

<p>The OpenSSL adds a lot of weight to a crate unless you need it, you can use <a href="https://crates.io/crates/ring">ring</a> which reduced further 4 MB to 6 MB of my crate.</p>

<h1 id="further-reading">Further reading</h1>

<p><a href="https://github.com/johnthagen/min-sized-rust">Here is a great repo</a> with a lot more flags and tweaks, mostly under experimental flags or nightly Rust versions so use at your own risk.</p>

<h1 id="results">Results</h1>

<p>Using all the compile optimizations, I was able to reduce the output of one of my binaries from 66 MB to 24.7 MB. It‚Äôs still large but better.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I find myself writing a lot of Rust nowadays. I‚Äôm by no means an expert, but I need to make do with my limited knowledge. A constant problem I‚Äôm facing is that the binaries outputted by Rust are huge. This is especially a problem on mobile, where each megabyte counts.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Writting tests for Tauri Rust Commands</title><link href="https://ospfranco.com/writting-tests-for-tauri-rust-commands/" rel="alternate" type="text/html" title="Writting tests for Tauri Rust Commands" /><published>2024-06-05T00:00:00+02:00</published><updated>2024-06-05T00:00:00+02:00</updated><id>https://ospfranco.com/writting%20tests%20for%20tauri%20rust%20commands</id><content type="html" xml:base="https://ospfranco.com/writting-tests-for-tauri-rust-commands/"><![CDATA[<p>I‚Äôm now in charge of a Tauri app and there is a lot of native Rust functionality that needs to be exposed to the JS side. Like any principled dev I want to write tests for my code.</p>

<p>The official documentation says one should write e2e tests with a UI simulation framework to test this functionality but that is way to cumbersome. I wanted unit tests for my Rust code. Also, I did not have stateless Rust functions, but functions where Tauri itself managed the state, so I needed to mock the entire Tauri app stack.</p>

<p>Credit where is due this <a href="https://stackoverflow.com/questions/77524788/writing-tests-for-tauri-commands-how-to-access-and-manage-state-in-test-environ">Stack Overflow answer</a> provided the info I was looking for.</p>

<p>However Tauri <code>1.6.7</code> broke this functionality and <code>1.6.8</code> fixed it by adding a new parameter.</p>

<p>Without further ado, first you need to add the <code>test</code> feature in your Tauri dependency:</p>

<pre><code class="language-toml">tauri = { version = "1.6.8", features = ["api-all", "updater", "test"] }
</code></pre>

<p>Then you can write your test like so:</p>

<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;
    use tauri::{
        test::{mock_context, noop_assets, MockRuntime},
        App,
    };

    fn before_each() -&gt; Result&lt;tauri::App&lt;MockRuntime&gt;, std::io::Error&gt; {
        let app = tauri::test::mock_builder()
            .plugin(super::init_plugin())
            .build(mock_context(noop_assets()))
            .unwrap();

        // Any other setup code you need
        Ok(app)
    }

    async fn after_each(app: App&lt;MockRuntime&gt;) {
        // your clean up code
    }

    #[tokio::test]
    async fn should_return_0_with_no_loaded_models() {
        let app = before_each().unwrap();
        let window = app.get_window("main").unwrap();
        let foo = tauri::test::get_ipc_response::&lt;Vec&lt;String&gt;&gt;(
            &amp;window,
            tauri::InvokePayload {
                cmd: "plugin:my_plugin|foo".into(),
                tauri_module: None,
                invoke_key: Some(tauri::test::INVOKE_KEY.into()),
                callback: tauri::api::ipc::CallbackFn(0),
                error: tauri::api::ipc::CallbackFn(1),
                inner: serde_json::json!({}),
            },
        );

        assert!(foo.is_ok());

        after_each(app).await;
    }

}

</code></pre>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I‚Äôm now in charge of a Tauri app and there is a lot of native Rust functionality that needs to be exposed to the JS side. Like any principled dev I want to write tests for my code.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">React Native Security Guide</title><link href="https://ospfranco.com/react-native-security-guide/" rel="alternate" type="text/html" title="React Native Security Guide" /><published>2024-05-30T00:00:00+02:00</published><updated>2024-05-30T00:00:00+02:00</updated><id>https://ospfranco.com/react%20native%20security%20guide</id><content type="html" xml:base="https://ospfranco.com/react-native-security-guide/"><![CDATA[<p>Like any other software development framework, security should be a top priority when developing React Native applications. However, there are a lot of misconceptions, fueled by the existence of packages and the lack of targeted information.</p>

<p>In this guide, we will explore various security considerations and best practices that every React Native developer should be aware of. If you find anything incorrect or have feedback, please reach out! This is a topic we should all care about.</p>

<h1 id="preface">Preface</h1>

<p>Let‚Äôs address this upfront: there is no real way to protect data once it is on the device. A motivated attacker with root or hardware access to the device will eventually be able to bypass security features when storing on-device data. Here is a <a href="https://blog.1password.com/local-threats-device-protections/">1Password write-up</a> that explains this well.</p>

<p>As we are not all building vault apps, this should be our guiding principle: <strong>do not put anything on the user‚Äôs device that you cannot afford to leak</strong>.</p>

<p>But that doesn‚Äôt mean all is lost. If the attacker does not have direct access to the machine, applying protections will still be a sufficient deterrent (and secure enough unless they actually get hold of the hardware). Using the best-known security practices can make some attacks so cumbersome that they act as a deterrent, so we should still use them.</p>

<h1 id="secrets">Secrets</h1>

<p>Armed with this knowledge, there is one inconvenient truth: <strong>you won‚Äôt be able to protect secrets like API keys for third-party services</strong>. No matter how you store or obfuscate them, or what packages promise. You also won‚Äôt be able to protect your encryption keys, which means <strong>you won‚Äôt be able to protect the encrypted user data</strong> (again, if the hardware is compromised). The difference lies in the fact that user data belongs to the user; they can hack their own app/device and see their data, but they had access to this data anyway. The problematic part is the secrets, as they are shared among your users.</p>

<p>Is there a way to protect secrets? Using a gateway would be one way, but sometimes it is not possible, for example, when using a third-party SDK that ingests the key directly. There is nothing we can do about that.</p>

<p>An important thing to note here is the existence of device attestation. Device attestation is a process where the OS tries to verify that the device and/or app has not been tampered with. There are <a href="https://support.apple.com/guide/deployment/managed-device-attestation-dep28afbde6a/web">APIs for iOS</a> and <a href="https://developer.android.com/privacy-and-security/safetynet/attestation">Android</a>. Some companies offer this as a service with an SDK, allowing you to verify the device/app before sending data to it. However, this is a not very well-explored topic and may be time-consuming or expensive.</p>

<p>With device attestation, you could have a more secure (read: more inconvenient to hack) secret management:</p>

<ol>
  <li>On app start, perform device attestation. If it fails: game over, you tampered with the device/app, so no access.</li>
  <li>On first start, download the secrets and store them in your favorite cryptographically secure storage.</li>
  <li>Combine this with partial keys that need to be fetched from a server each time to decode the secrets/data.</li>
</ol>

<p>Again, once a hacker has access to the device, it‚Äôs game over. They can even mess with the OS internals to defeat device attestation, but at least you can make their lives harder.</p>

<p>A final point to mention is packages like <code>react-native-dotenv</code> and <code>react-native-config</code>. I don‚Äôt like them because they can be misleading (and have caused me trouble compiling them in the past). These ‚Äúenvironment variables‚Äù packages still package your environment variables inside the app bundle and then read them at runtime. While they have not intentionally deceived people into thinking they are secure, the naming and the mixing of real environment variables with what they do have at least led unaware developers to think their secrets are secure (speaking from personal experience).</p>

<p>The reason why environment variables in things like Docker containers and server environments are secure is that they reside in memory, are not persisted, and are isolated by running on the server where (hopefully) the only point of entry is a secure HTTP API. This is not the case for mobile apps (regardless of the language/framework you are using).</p>

<h1 id="user-data">User Data</h1>

<p>Given this knowledge, why should we bother encrypting user data? Well, again, if we consider the worst-case scenario, the world is bleak. But if we assume we are running on an untampered device/OS, the fact that we protect data from other apps and script-kiddies is still worthwhile. Most packages have some way of encrypting your data via an encryption key.</p>

<p>Which algorithm they use and if they are actually securing the data is a per-package question. Many of them (at least in the React Native world) have hand-rolled their encryption, use dubious implementations, or are outdated. It‚Äôs too much to cover in this article, so I will just give you an ideal workflow that should be secure (barring implementation errors in the libraries themselves):</p>

<h2 id="generate-and-securely-store-your-encryption-key">Generate and Securely Store Your Encryption Key</h2>

<p>Most packages tell you to do this:</p>

<pre><code class="language-ts">const myKey = "password_is_password";

const storage = MyStateLibrary.create({
  encryptionKey: myKey,
});
</code></pre>

<p>The problem with this approach is that anyone can decompile your app and read the value of <code>myKey</code> (no matter how you obfuscate it). This is even worse in React Native, where you can just decompress an APK/IPA and take a look at the minified JS/TS code. I have mentioned in previous articles how looking into the JS bundle can leak valuable business logic and allow competitors to copy functionality.</p>

<p>Here is a better approach to generate and store your encryption key. I‚Äôll use my package <code>op-s2</code> for this, but you can use <a href="https://docs.expo.dev/versions/latest/sdk/securestore/">Expo Secure Store</a> or <a href="https://github.com/oblador/react-native-keychain">react-native-keychain</a> they are all (more-or-less) equivalent but I tried to make op-s2 the simplest. Both work by storing data in the Keychain on iOS and by generating keys with the KeyStore API on Android, which are backed by hardware (when possible on Android) and are secure (as secure as it gets with untampered devices).</p>

<pre><code class="language-ts">import { set } from "@op-engineering/op-s2";
import { generateSecureRandom } from "react-native-securerandom";

async function generateKey() {
  // generate secure bytes using the t2 chip (SecRandomCopyBytes) and Secure Random on Android
  const secureBytes = await generateSecureRandom(42);

  // on the latest versions of RN btoa is part of hermes
  const key = btoa(String.fromCharCode.apply(null, secureBytes));

  const { error } = set({
    key: "myKey",
    value: key,
    withBiometrics: true, // This means a FaceID/biometrics prompt will appear every time. See the docs if you don't want to use this
  });
}
</code></pre>

<p><code>withBiometrics</code> is the safest but most cumbersome option, as it requires user authentication every time you want to read this key. You can leave it out, and it will still be secure. How are these packages secure? Because KeyStore/Keychain actually allow access on a per-app bundle basis (with signature verification, I believe). You only have access to the data you have created; you cannot read values from other apps/processes. So, at least we have per-app security.</p>

<p>Then, when you start your storage, you can pass this key:</p>

<pre><code class="language-ts">const myKey = get({ key: "myKey", withBiometrics: true });

const storage = MyStateLibrary.create({
  encryptionKey: myKey,
});

const myKey = null;
// You can even trigger garbage collection to make a timed attack even harder
</code></pre>

<p>Again, nothing is truly secure, but at least we have an extra layer of protection. Clearing the memory is also a best practice to prevent leaks. We then rely on the library to have correctly implemented an encryption algorithm.</p>

<blockquote>
  <p>As a funny side note:
Apple‚Äôs Keychain is just an API wrapper against a SQLite database that has some OS protections bolted in.
Keystore is just an API for retrieving/generating/saving secure crypto keys. The actual API that saves data is EncryptedSharedPreferences, which just saves files to disk with encryption bolted on.</p>

  <p>:)</p>
</blockquote>

<h2 id="use-secure-storage">Use Secure Storage</h2>

<p>Once you have your encryption keys securely stored, it‚Äôs time to move on to storing the data itself securely. Here, some libraries are already prepared for that. MMKV allows you to specify an encryption key:</p>

<pre><code class="language-ts">import { get } from "@op-engineering/op-s2";
import { MMKV, Mode } from "react-native-mmkv";

const myKey = get({ key: "myKey", withBiometrics: true });

export const storage = new MMKV({
  id: `user-${userId}-storage`,
  path: `${USER_DIRECTORY}/storage`,
  encryptionKey: myKey,
  mode: Mode.MULTI_PROCESS,
});
</code></pre>

<p>Another alternative is using an encrypted fork of SQLite called SQLCipher, which you can use via <a href="https://github.com/OP-Engineering/op-sqlite">op-sqlite</a>. You just need to enable SQLCipher support in the <code>package.json</code>:</p>

<pre><code class="language-json">"op-sqlite": {
  "sqlcipher": true
}
</code></pre>

<p>Then, when you open your database:</p>

<pre><code class="language-ts">const { open } from '@op-engineering/op-sqlite';

const myKey = get({ key: "myKey", withBiometrics: true });

const db = open({
  name: 'my_secure_db.sqlite',
  encryptionKey: myKey
});
</code></pre>

<p>This will fully encrypt the data stored on disk with a bit of overhead. As long as your encryption key is not compromised, it should be safe.</p>

<h1 id="hardware-keys">Hardware Keys</h1>

<p>I have to mention hardware keys, which circumvent the issue of the attacker having remote access to the device. Since they are separate from the OS, they cannot be easily compromised (apart from being physically stolen) and provide an extra layer of security.</p>

<p>If your app requires an even higher level of security, it might be worth looking into them. I have bridged the Yubico SDK for RN, but it‚Äôs not currently open source. <a href="https://developers.yubico.com/Developer_Program/Guides/User_Loaded_Data.html">Although you cannot save data to a YubiKey</a>, authentication would be enough to use secure bytes as an encryption key. As I‚Äôve shown in this article, as long as the encryption key is safe, you can consider your data safe enough. If someone is willing to sponsor the work, I would be willing to create a Turbo module to make this functionality available to React Native apps.</p>

<h1 id="encryption-algorithms">Encryption algorithms</h1>

<p>If you are on the market for rolling your own encryption or need some crypto math, just use <a href="https://github.com/margelo/react-native-quick-crypto">react-native-quick-crypto</a>, it‚Äôs a (re)implementation of the <a href="https://nodejs.org/api/crypto.html">node‚Äôs crypto module</a>. There are many people who are not fans of the API, doesn‚Äôt matter. It‚Äôs proven and fast since it uses C++ bindings. It‚Äôs also somewhat incomplete but more APIs can be added if you are willing to sponsor the work.</p>

<h1 id="conclusion">Conclusion</h1>

<p>It‚Äôs still worth looking into the <a href="https://reactnative.dev/docs/security#storing-sensitive-info">official RN documentation</a>; however, I hope this guide is a bit more hands-on.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Like any other software development framework, security should be a top priority when developing React Native applications. However, there are a lot of misconceptions, fueled by the existence of packages and the lack of targeted information.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Rust modules in React Native</title><link href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/" rel="alternate" type="text/html" title="Rust modules in React Native" /><published>2024-05-08T15:00:00+02:00</published><updated>2024-05-08T15:00:00+02:00</updated><id>https://ospfranco.com/post/2024/05/08/react%20native%20rust%20module%20guide</id><content type="html" xml:base="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/"><![CDATA[<p>This is a tutorial on how I integrate Rust modules, but in the video form I go over the concepts that actually make this work, so you can adjust and understand the tooling behind and you can maintain your integration.</p>

<iframe class="w-full h-96" src="https://www.youtube.com/embed/PPU4Hrz4J_s" title="YouTube video player" frameborder="0" allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h1 id="basic-setup">Basic Setup</h1>

<ul>
  <li>Set up Rust compiler on your computer, just follow the instructions on the Rust website (use <code>rustup</code>, brew will give you headaches).</li>
  <li>In order to compile the Android version you are going to use the <code>ndk</code> create which simplifies the command to compile the rust library for Android. Install it via <code>cargo install ndk</code></li>
  <li>
    <p>Create a crate where we will put all of our Rust lib code and infra scripts. In my case I will call it <code>my_sdk</code></p>

    <pre><code class="language-bash">cargo new my_sdk
</code></pre>
  </li>
  <li>
    <p>Create a <code>rust-toolchain.toml</code> in the project folder you just created. This will add all the necessary architectures to compile your project:</p>

    <pre><code class="language-toml">[toolchain]
channel = "stable"
targets = ["x86_64-apple-ios", "aarch64-apple-ios", "aarch64-apple-ios-sim", "aarch64-linux-android", "armv7-linux-androideabi", "x86_64-linux-android", "i686-linux-android"]
</code></pre>
  </li>
  <li>Change name of <code>main.rs</code> to <code>lib.rs</code></li>
  <li>
    <p>Add your API code on lib.rs</p>

    <pre><code class="language-rust">#[no_mangle]
extern "C" fn sum(a: i32, b: i32) {
  a + b
}
</code></pre>
  </li>
  <li>
    <p>We will use a crate called <code>cbindgen</code> that will help us generate a C header for our Rust functions. We will automate the header creation by creating a <code>build.rs</code> that runs every time our project is compiled/checked. First we are going to add the dependency as a <code>[build-dependencies]</code>, the project <code>Cargo.toml</code>:</p>

    <pre><code class="language-toml">[build-dependencies]
cbindgen = "0.26.0"
</code></pre>
  </li>
  <li>
    <p>Then on the root of the project create a <code>build.rs</code> file:</p>

    <pre><code class="language-rust">extern crate cbindgen;

use std::env;

fn generate_c_headers() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("my_sdk_h")
        .with_autogen_warning(
            "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */",
        )
        .with_namespace("my_sdk")
        .with_cpp_compat(true)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("generated/include/my_sdk.h");
}

fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo:rerun-if-changed=src/lib.rs");
    generate_c_headers();
}
</code></pre>
  </li>
  <li>
    <p>Modify the <code>cargo.toml</code> to compile as static library. You can also create a dynamic library that can be loaded on runtime on Android, but both should work. The <code>jni</code> dependency is only necessary if you are planing to call your code from Java/Kotlin.</p>

    <pre><code class="language-toml">[package]
name = "SDK"
version = "0.1.0"
edition = "2021"

[lib]
name = "SDK"
crate-type = ["staticlib"]

[dependencies]
libc = "0.2.80" # Allows to use c types CString, c_char, etc.
jni = "0.17.0" # OPTIONAL Allows to write JNI bindings directly from Rust

[build-dependencies]
cbindgen = "0.26.0"
</code></pre>
  </li>
  <li>(Optional) In my experience static binaries on iOS are OK, but on Android they can be huge. Ideally you would specify <code>crate-type = ['staticlib', 'dylib']</code> and just be on your merry way, however, it seems this bloats the static lib massively. In order to get a static binary for iOS and a dynamic one for Android you can set <code>crate-type = ['dylib']</code> and change the compilation command for iOS to <code>cargo rustc --crate-type=staticlib ...</code></li>
</ul>

<h1 id="ios">iOS</h1>

<ul>
  <li>
    <p>We are going to use <code>Make</code> to compile and package the library. No specific reason for it you can create your script on JS too.</p>

    <pre><code class="language-make">ARCHS_IOS = x86_64-apple-ios aarch64-apple-ios aarch64-apple-ios-sim
ARCHS_ANDROID = aarch64-linux-android armv7-linux-androideabi x86_64-linux-android i686-linux-android
LIB = libmy_sdk.a
DYLIB = libmy_sdk.so
XCFRAMEWORK = my_sdk.xcframework

all: ios android

ios: $(XCFRAMEWORK)

android: $(ARCHS_ANDROID)
  # After build is done copy files into the android folder
  mkdir -p ../android/app/src/main/jniLibs
  mkdir -p ../android/app/src/main/jniLibs/x86
  mkdir -p ../android/app/src/main/jniLibs/arm64-v8a
  mkdir -p ../android/app/src/main/jniLibs/armeabi-v7a
  mkdir -p ../android/app/src/main/jniLibs/x86_64


  cp ./target/i686-linux-android/release/$(DYLIB) ../android/app/src/main/jniLibs/x86/$(DYLIB)
  cp ./target/aarch64-linux-android/release/$(DYLIB) ../android/app/src/main/jniLibs/arm64-v8a/$(DYLIB)
  cp ./target/arm-linux-androideabi/release/$(DYLIB) ../android/app/src/main/jniLibs/armeabi-v7a/$(DYLIB)
  cp ./target/x86_64-linux-android/release/$(DYLIB) ../android/app/src/main/jniLibs/x86_64/$(DYLIB)

.PHONY: $(ARCHS_IOS)
$(ARCHS_IOS): %:
  cargo build --target $@ --release

.PHONY: $(ARCHS_ANDROID)
$(ARCHS_ANDROID): %:
  cargo ndk --target $@ --platform 31 --release

$(XCFRAMEWORK): $(ARCHS_IOS)
  mkdir -p simulator_fat
  lipo -create target/x86_64-apple-ios/release/$(LIB) target/aarch64-apple-ios-sim/release/$(LIB) -output simulator_fat/$(LIB)
  xcodebuild -create-xcframework -library target/aarch64-apple-ios/release/$(LIB) -headers include -library simulator_fat/$(LIB) -headers include -output $@
  cp -r $@ ../ios/$@
</code></pre>

    <blockquote>
      <p>You see on iOS we are creating a xcframework, that is because the architectures conflict (iOS and iOS sim m1), so we use a xcframework to package it nicely for Xcode to build our app.</p>
    </blockquote>
  </li>
  <li>The <code>copy-ios.sh</code> is just a simple scripts that copies the generated xcframework to a more convenient location. You can leave it out if you modify the locations manually.</li>
  <li>Add generated <code>.xcframework</code> to Xcode
    <ul>
      <li>If you are doing this on a single project then dragging and dropping is the easiest, just make sure in the project properties mark the xcframework as embed and sign.</li>
      <li>If you are doing this on React Native, as part of a library, then you need to modify your podspec. Just drop the <code>xcframework</code> somewhere and then on your podspec add <code>s.vendored_frameworks = "my_sdk.xcframework"</code></li>
    </ul>
  </li>
  <li>You should now be able to simply import the header file (<code>#include "my_sdk.h"</code>) and call any Rust function from any Obj-C++ file</li>
</ul>

<h1 id="binary-size">Binary size</h1>

<p>As mentioned in a previous point, the sizes of compiled Rust binaries can be quite large. Which is a problem when targeting mobile platforms. You need to turn on optimizations to get the binary size down, check out the <a href="https://ospfranco.com/rust-reduce-binary-size/">size optimization guide</a>.</p>

<h1 id="android">Android</h1>

<ul>
  <li>
    <p>The <code>ndk</code> crate simplifies the generation of Android Rust modules massively. You need to have the variables set up properly though. Make sure you have the Android NDK properly installed in your system. Then set the following environment variables in your system. Change the NDK version to whatever you have installed or you need:</p>

    <pre><code class="language-bash">export ANDROID_SDK_ROOT=$HOME/Library/Android/sdk
export ANDROID_HOME=$HOME/Library/Android/sdk
export ANDROID_NDK_HOME=$ANDROID_HOME/ndk/25.1.8937393
</code></pre>
  </li>
  <li>
    <p>We need to tell cmake to link the library when compiling our native module, on the <code>CMakeLists.txt</code> file add the following:</p>

    <pre><code class="language-make">make_path(SET MY_SDK_LIB ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libmy_sdk.a NORMALIZE)
add_library(my_sdk STATIC IMPORTED)
set_target_properties(my_sdk PROPERTIES IMPORTED_LOCATION ${MY_SDK_LIB})

target_link_libraries(tm
        jsi
        my_sdk
        react_nativemodule_core
        react_codegen_AppSpecs
)
</code></pre>
  </li>
  <li>We will still not be able to call our Rust code from Java, because we need to go through the JNI and the JNI is very picky regarding names, we need to create specific binding for Android, on the <code>lib.rs</code> and the following block</li>
  <li>We can finally call <code>make android</code> and the library will be created for us</li>
  <li>
    <p><strong>Optional</strong> If you want to call the functions from Java/Kotlin (and not from C++) you need to create another binding using Android‚Äôs JNI:</p>

    <pre><code class="language-rust">// On Android function names need to follow the JNI convention
pub mod android {
  extern crate jni;

  use self::jni::JNIEnv;
  use self::jni::objects::JClass;
  use self::jni::sys::jstring;

  #[no_mangle]
  pub unsafe extern fn Java_com_samplesdk_BindingsModule_helloWorld(env: JNIEnv, _: JClass) -&gt; jstring {
    let output = env.new_string("Hello from Rust!").expect("Couldn't create java string!");
    output.into_inner()
  }
}
</code></pre>
  </li>
  <li>
    <p>We can now create a RN Module (or JSI module) and simply load the library and call it (via JNI of course)</p>

    <pre><code class="language-java">package com.samplesdk;

import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.util.RNLog;
import java.util.Map;
import java.util.HashMap;

public class BindingsModule extends ReactContextBaseJavaModule {


    BindingsModule(ReactApplicationContext context) {
        super(context);
        // If you are using a Android dylib, you will have to load it now!
    }

    @Override
    public String getName() {
        return "Bindings";
    }

    @ReactMethod
    public void init(String apiKey) {
        RNLog.w(this.getReactApplicationContext(), "BindingsModule.init() called with apiKey: " + apiKey + "calling rust");
        String result = helloWorld();
        RNLog.w(this.getReactApplicationContext(), "Rust says: " + result);
    }

    private static native String helloWorld();
}
</code></pre>
  </li>
</ul>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[This is a tutorial on how I integrate Rust modules, but in the video form I go over the concepts that actually make this work, so you can adjust and understand the tooling behind and you can maintain your integration.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>