<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ospfranco.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ospfranco.com/" rel="alternate" type="text/html" /><updated>2025-04-06T08:54:20+09:00</updated><id>https://ospfranco.com/feed.xml</id><title type="html">Oscar Franco Personal Website</title><author><name>Oscar Franco</name></author><entry><title type="html">Fixing mini 4 pro, failing to load images in quick transfer</title><link href="https://ospfranco.com/fixing-mini-4-pro,-failing-to-load-images-in-quick-transfer/" rel="alternate" type="text/html" title="Fixing mini 4 pro, failing to load images in quick transfer" /><published>2025-04-06T00:00:00+09:00</published><updated>2025-04-06T00:00:00+09:00</updated><id>https://ospfranco.com/fixing%20mini%204%20pro,%20failing%20to%20load%20images%20in%20quick%20transfer</id><content type="html" xml:base="https://ospfranco.com/fixing-mini-4-pro,-failing-to-load-images-in-quick-transfer/"><![CDATA[<p>I have a DJI Mini Pro drone (had the 3 two times and lost them, and now a 4). I love this little thing. However, I have a few issues with this delicate piece of technology.</p>

<p>First one that seems non-solvable are transfer speeds. The 3 would do 10 to 20 mbits/s transfer. This new one seems to be a lot slower 1 to 3 mbits/second. Scouring online, seems to suggest one needs to turn off celullar data and the issue might go away. Big problem, but nothing I can do about that.</p>

<p>However, I had a more serious issue the other day. Here are some steps for those unlucky souls like me.</p>

<p>When entering quick-transfer mode all of the sudden none of the pictures/videos would show in the gallery. All I got was a “Failed to load, tap to try again” message on the screen.</p>

<p>I did all I could think off:</p>

<ul>
  <li>Drone, controller and app where updated</li>
  <li>Check SD card on computer</li>
  <li>Format SD card</li>
  <li>Reset all settings on drone</li>
  <li>Mutiple restarts, with SD card out, letting the drone sit idle, etc.</li>
  <li>Try a different SD card</li>
</ul>

<p>I got in touch with DJI support, they pointed me to <a href="https://www.dji.com/jp/downloads/softwares/dji-assistant-2-consumer-drones-series">one tool</a> they have to reflash the firmware</p>

<p>After multiple reflashes and a downgrade, it was still not working. I was about to give up when just clicking through the settings I noticed the internal storage had 0 free space (should have 2 gb). Knowning what I know about computers, this was a desperate last attempt to get it working. I formated the internal storage and voila! All of the sudden the gallery started working again.</p>

<p>This is clearly an oversight on DJI’s firmware. Lack of error messages/user feedback to debug the issue. Etc. At least I got the drone back in working order, so hopefully this will be useful to others.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I have a DJI Mini Pro drone (had the 3 two times and lost them, and now a 4). I love this little thing. However, I have a few issues with this delicate piece of technology.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Better repo tasks and scripts with mise and zx</title><link href="https://ospfranco.com/better-tasks-and-scripts-with-mise-and-zx/" rel="alternate" type="text/html" title="Better repo tasks and scripts with mise and zx" /><published>2025-03-26T00:00:00+09:00</published><updated>2025-03-26T00:00:00+09:00</updated><id>https://ospfranco.com/better%20tasks%20and%20scripts%20with%20mise%20and%20zx</id><content type="html" xml:base="https://ospfranco.com/better-tasks-and-scripts-with-mise-and-zx/"><![CDATA[<p>Recently I’ve been working with repos that have multiple languages and build systems rolled into one. Talking about iOS/Android/Rust/Node/Flutter. The plethora of build systems, tools and quirks brings a lot of complexity, specially when working within a team, where every one needs to be able to run the same commands to build, test, lint, etc.</p>

<h1 id="previous-art">Previous Art</h1>

<p>From working with other teams, each language/ecosystem have their own way of doing things. Some of the common patterns I’ve seen are:</p>

<ul>
  <li>The god awfulness that is cmake, frankensteined to work with modern tools, such as Rust. This was the latest approach that I took, just because I did not know any better tool. Works for simple flows, but brakes down once you need to start parsing params, setting variables, etc.</li>
  <li>Writing lots of Rust to perform as a shell scripting tool. Hard to read/write as one is creating a DSL on top of Rust. Usually, takes the name of xtask, there is even a <a href="https://docs.rs/xtasks/latest/xtasks/">crate</a> aimed at automating some of this pain.</li>
  <li>Npm scripts, combined with shell scripts</li>
  <li>Raw dogging node scripts that spawn processes</li>
  <li>There are ofc other tools like <code>make</code>, <code>rake</code>, <code>Ninja</code>, etc.</li>
</ul>

<p>You can see the wild west that this endevaour is. These all work but require too much finagling to get right. I wanted something that was simple, easy to read, and easy to write. Preferible in a language/ecosystem that I know. JS is the easiest one, but then it’s one more tool in the chain that my team needs to install, but then found a tooling pair that allows for one install command that takes care of everything.</p>

<h1 id="mise">Mise</h1>

<p>I’m a big fan of tool managers. Journey started with <code>asdf</code> and I’m now using <code>mise</code>. <code>mise</code> is a tool manager that allows you to install tools from a single file. It’s like a package manager for languages/runtimes/tasks/etc. It basically allows you to define a single <code>mise.toml</code> where you can have per folder tools.</p>

<p>Let’s say, I can have the specific bun/node version that I need my team to have. Without having to seat down with them to uninstall their manual node installation, install nvm, then update their Rust version. etc etc.</p>

<h1 id="zx">Zx</h1>

<p><a href="https://github.com/google/zx"><code>zx</code></a> is a package from Google that allows to write better scripts in JS. Basically invoke shell commands within a JS file without dealing with the idiosincracies of bash/zsh/whatever shell you are using.</p>

<h1 id="putting-it-all-together">Putting it all together</h1>

<p>At the end, I have a <code>mise.toml</code> that looks like this (this is just an example):</p>

<pre><code class="language-toml">[tools]
node = "14.18.1"
bun = "0.1.0"
rust = "1.58.0"

[hooks]
postinstall = "bun install"

[tasks]
build = "bun zx scripts/build.mjs"
</code></pre>

<p>And a <code>scripts/build.mjs</code> that looks like this:</p>

<pre><code class="language-js">import "zx/globals";

// You can do more things here, like parse the arguments, import other files, etc
await $`cargo build --release`;
await $`flutter build ios`;
</code></pre>

<p>Then on the README for my team it gets simple boils down to:</p>

<ul>
  <li><code>brew install mise</code></li>
  <li><code>mise settings experimental=true</code>, this is needed to enable the hooks, will go away in the future</li>
  <li><code>mise install</code></li>
  <li><code>mise build</code> to build the project. On my project I have extended this with params like <code>mise build ios debug</code> to build the iOS app in debug mode.</li>
</ul>

<p>No more fighting with tool versions, no more fighting with build systems. Everyone is on the same versions, with a reproducible yet native environment, with a single entry point for scripts and the scripts themselves written in a non-retarded language.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Recently I’ve been working with repos that have multiple languages and build systems rolled into one. Talking about iOS/Android/Rust/Node/Flutter. The plethora of build systems, tools and quirks brings a lot of complexity, specially when working within a team, where every one needs to be able to run the same commands to build, test, lint, etc.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">BarcelonaJS Talk</title><link href="https://ospfranco.com/barcelonajs-talk/" rel="alternate" type="text/html" title="BarcelonaJS Talk" /><published>2025-02-10T00:00:00+09:00</published><updated>2025-02-10T00:00:00+09:00</updated><id>https://ospfranco.com/barcelonajs%20talk</id><content type="html" xml:base="https://ospfranco.com/barcelonajs-talk/"><![CDATA[<p>I recently gave a talk in BarcelonaJS MeetUp group regarding React Native and the new arch.</p>

<p>Here is the video recording:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/2SsmFFMsLCo?start=711" frameborder="0" allowfullscreen=""></iframe>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I recently gave a talk in BarcelonaJS MeetUp group regarding React Native and the new arch.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Loading dylibs in iOS</title><link href="https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/" rel="alternate" type="text/html" title="Loading dylibs in iOS" /><published>2025-01-21T00:00:00+09:00</published><updated>2025-01-21T00:00:00+09:00</updated><id>https://ospfranco.com/generating%20a%20xcframework%20with%20dylibs%20for%20ios</id><content type="html" xml:base="https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/"><![CDATA[<p>Apple has terribly messed with dynamic library loading in iOS, has diverged from the unix standard. This was an absolute pain to get right, so I hope I will save someone some time in case you ever need to compile a dylib for iOS.</p>

<h1 id="frameworks">Frameworks</h1>

<p>In order to load dynamic libraries in iOS they need to be packaged in a <code>.framework</code>. Let’s skip most of the explanation and just give you a template you can use. These frameworks need to be embbeded in a <code>.xcframework</code> that will load the correct version for the architecture (arm, arm-simulator, intel-simulator).</p>

<h1 id="compile-your-library">Compile your library</h1>

<p>Here is the <code>Makefile</code> you need, it’s for sqlitevec an sqlite extension but you can easily figure out how to compile your own project:</p>

<pre><code class="language-make">MIN_IOS_VERSION = 8.0

# iOS SDK paths
IOS_SDK_PATH = $(shell xcrun --sdk iphoneos --show-sdk-path)
IOS_SIMULATOR_SDK_PATH = $(shell xcrun --sdk iphonesimulator --show-sdk-path)

# iOS cross-compiler toolchains
CC_ios_arm64 = $(shell xcrun --sdk iphoneos --find clang)
CC_ios_x86_64 = $(shell xcrun --sdk iphonesimulator --find clang)

# Output directories for iOS
OUT_DIR_ios_arm64 = dist/ios/arm64
OUT_DIR_ios_x86_64 = dist/ios/x86_64
OUT_DIR_ios_arm64_simulator = dist/ios/arm64_simulator

# iOS-specific flags
IOS_CFLAGS = -Ivendor/ -I./ -O3 -fembed-bitcode -fPIC
IOS_LDFLAGS = -Wl,-ios_version_min,$(MIN_IOS_VERSION)
IOS_ARM64_FLAGS = -target arm64-apple-ios$(MIN_IOS_VERSION) -miphoneos-version-min=$(MIN_IOS_VERSION)
IOS_ARM64_SIM_FLAGS = -target arm64-apple-ios-simulator$(MIN_IOS_VERSION) -mios-simulator-version-min=$(MIN_IOS_VERSION)
IOS_X86_64_FLAGS = -target x86_64-apple-ios-simulator$(MIN_IOS_VERSION) -mios-simulator-version-min=$(MIN_IOS_VERSION)

# Create folders per iOS architecture
$(OUT_DIR_ios_arm64):
	mkdir -p $@

$(OUT_DIR_ios_x86_64):
	mkdir -p $@

$(OUT_DIR_ios_arm64_simulator):
	mkdir -p $@

# Rule for compiling for iOS arm64 (device)
ios_arm64: $(OUT_DIR_ios_arm64)
	$(CC_ios_arm64) $(CFLAGS) $(IOS_CFLAGS) $(IOS_ARM64_FLAGS) -isysroot $(IOS_SDK_PATH) -c sqlite-vec.c -o $(OUT_DIR_ios_arm64)/sqlite-vec.o
	$(CC_ios_arm64) -dynamiclib -o $(OUT_DIR_ios_arm64)/sqlitevec $(OUT_DIR_ios_arm64)/sqlite-vec.o -isysroot $(IOS_SDK_PATH) $(IOS_LDFLAGS)

# Rule for compiling for iOS x86_64 (simulator)
ios_x86_64: $(OUT_DIR_ios_x86_64)
	$(CC_ios_x86_64) $(CFLAGS) $(IOS_CFLAGS) $(IOS_X86_64_FLAGS) -isysroot $(IOS_SIMULATOR_SDK_PATH) -c sqlite-vec.c -o $(OUT_DIR_ios_x86_64)/sqlite-vec.o
	$(CC_ios_x86_64) $(IOS_X86_64_FLAGS) -dynamiclib -o $(OUT_DIR_ios_x86_64)/sqlitevec $(OUT_DIR_ios_x86_64)/sqlite-vec.o -isysroot $(IOS_SIMULATOR_SDK_PATH)

# Rule for compiling for iOS arm64 (simulator)
ios_arm64_sim: $(OUT_DIR_ios_arm64_simulator)
	$(CC_ios_arm64) $(CFLAGS) $(IOS_CFLAGS) $(IOS_ARM64_SIM_FLAGS) -isysroot $(IOS_SIMULATOR_SDK_PATH) -c sqlite-vec.c -o $(OUT_DIR_ios_arm64_simulator)/sqlite-vec.o
	$(CC_ios_arm64) -dynamiclib -o $(OUT_DIR_ios_arm64_simulator)/sqlitevec $(OUT_DIR_ios_arm64_simulator)/sqlite-vec.o -isysroot $(IOS_SIMULATOR_SDK_PATH)

# Rule to compile for all iOS architectures
ios: ios_arm64 ios_x86_64 ios_arm64_sim
  # Create a single fat for simulators
	lipo -create ./dist/ios/x86_64/sqlitevec ./dist/ios/arm64_simulator/sqlitevec -output dist/ios/sim_fat/sqlitevec

  # Move generated binary to the template xcframework folder
	cp ./dist/ios/arm64/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64/sqlitevec.framework/

  # Set @rpath
	install_name_tool -id @rpath/sqlitevec.framework/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64/sqlitevec.framework/sqlitevec

  # Move generated binary to the template xcframework folder
	cp ./dist/ios/sim_fat/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64_x86_64-simulator/sqlitevec.framework/

  # Set @rpath
	install_name_tool -id @rpath/sqlitevec.framework/sqlitevec ./templates/sqlitevec.xcframework/ios-arm64_x86_64-simulator/sqlitevec.framework/sqlitevec

.PHONY: ios ios_arm64 ios_x86_64 ios_arm64_sim
</code></pre>

<ol>
  <li>You first need to compile your library for iOS. There are a lot of things to take care here. Detecting the correct compiler chain. You NEED to make sure you are setting the correct min iPhone OS version (dylib support was added in iOS 8).</li>
  <li>Then compiling the library into an .o and then linking it as a dylib. Dynamic libraries in iOS have no extension. The make file creates a folder structure and drops the generated files in the correct places.</li>
  <li>Once this files are generated the makefile will try to merge the arm-simulator and intel-simulator binaries into a single “fat” binary. The reason is clashing of architectures (both arm-sim and intel-sim target the same “arch” so they clash and need to be merged into a “fat” binary).</li>
  <li>With the binary merged we can drop everything into a <code>.xcframework</code> template. <a href="https://github.com/OP-Engineering/op-sqlite/tree/main/ios/sqlitevec.xcframework">You can download it here</a>. You need of course rename it properly and modify the paths but by using a template we skip more not-so-important steps.</li>
  <li>With the files in the correct places we need to final set the <code>@rpath</code>. The rpath basically tells the OS where to find the canonical path of the file. It’s mean for the runtime linker to find the correct file from a memory safe location when the app is compiled in hardened mode. This is confusing, don’t think too much about it, it has to do with sandboxing and security of the OS.</li>
</ol>

<h1 id="xcframework">XCFramework</h1>

<p>After you got your library compiled correctly, it’s not enough to just drop them somewhere on iOS and call it a day. The <code>.xcframework</code> which basically is a folder that contains an <code>Info.plist</code>, tells Xcode which framework to load based on your computer arch and target. You <strong>could</strong> also create the <code>xcframework</code> via command, but it will not create the internal <code>frameworks</code> inside for you. Still useful command if you are compiling static libs:</p>

<pre><code class="language-sh">xcodebuild -create-xcframework -library ./sim_fat/libsqlite_vec.a -headers ../../ -library ./arm64/libsqlite_vec.a -include ../../ -output libsqlite_vec.xcframework
</code></pre>

<blockquote>
  <p>This is a sample command, won’t work for this particular dylib case. But if you just need static libs, this is it. Once you have everything packaged in an .xcframework your static libs (.a) are automatically loaded for you. No need to mess with the rpath and frameworks</p>
</blockquote>

<p>The <code>Info.plist</code> also contains entries to the folders which contain the <code>frameworks</code> that actually contain the dylibs.</p>

<h1 id="each-framework-infoplist">Each framework Info.plist</h1>

<p>Each <code>.framework</code> inside the <code>.xcframework</code> contains it’s own <code>Info.plist</code>. You can ignore most of this except the bundle identifier. This value is important because it will be used on runtime to load the binary. You should modify them to match your library name and bundle identifier (<code>CFBundleExecutable</code> tells the name of the binary, <code>CFBundleIdentifier</code> is needed to load the dylibs):</p>

<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
  &lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
  &lt;string&gt;en&lt;/string&gt;
  &lt;key&gt;CFBundleExecutable&lt;/key&gt;
  &lt;string&gt;sqlitevec&lt;/string&gt;
  &lt;key&gt;CFBundleIdentifier&lt;/key&gt;
  &lt;string&gt;com.ospfranco.sqlitevec&lt;/string&gt;
  &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
  &lt;string&gt;6.0&lt;/string&gt;
  &lt;key&gt;CFBundlePackageType&lt;/key&gt;
  &lt;string&gt;FMWK&lt;/string&gt;
  &lt;key&gt;CFBundleSignature&lt;/key&gt;
  &lt;string&gt;????&lt;/string&gt;
  &lt;key&gt;CFBundleVersion&lt;/key&gt;
  &lt;string&gt;1.0.0&lt;/string&gt;
  &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
  &lt;string&gt;1.0.0&lt;/string&gt;
	&lt;key&gt;MinimumOSVersion&lt;/key&gt;
  &lt;string&gt;8.0&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<h1 id="loading-it-in-runtime">Loading it in runtime</h1>

<p>After you have correctly created the <code>xcframework</code> you can then add it as a dependency in your project. Directly drop it into Xcode, or if you are using cocoapods declare as:</p>

<pre><code class="language-ruby">s.vendored_frameworks = "sqlitevec.xcframework"
</code></pre>

<p>This just takes care of packaging into your app once you do <code>pod install</code>. Once the app starts you actually have load the dylib. Here is a snippet to do this:</p>

<pre><code class="language-objc">NSBundle *libsqlitevec_bundle = [NSBundle bundleWithIdentifier:@"com.ospfranco.sqlitevec"];
NSString *sqlite_vec_path = [libsqlitevec_bundle pathForResource:@"sqlitevec" ofType:@""];
</code></pre>

<p>This is not how you LOAD it, but rather how you find it in the file system. At least for my use case that is all I needed. I can then pass it to sqlite and it takes care of loading it on memory (via <code>dlopen</code> I guess, or some other system call).</p>

<h1 id="debugging">Debugging</h1>

<p>If you are unsure any of the steps above is not correctly applied you can verify them.</p>

<p>Verify the min OS version is set correctly by running:</p>

<pre><code>otool -l sqlitevec.framework/sqlitevec | grep -A 3 LC_VERSION_MIN_IPHONEOS
</code></pre>

<p>If the key is there you should see the set version. This is mandatory for the iOS device arm64 version. If not set then Apple will reject your embedded framework when you send the submission to the app store. It should look something like this:</p>

<pre><code>Load command 8
      cmd LC_VERSION_MIN_IPHONEOS
  cmdsize 16
  version 8.0
      sdk 8.0
</code></pre>

<p>The <code>@rpath also needs to be correct</code>, although it is done for you in the Makefile you can verify is properly set by running:</p>

<pre><code>otool -L sqlitevec.framework/sqlitevec
</code></pre>

<p>You should see an entry with <code>@rpath</code> like this:</p>

<pre><code>sqlitevec.framework/sqlitevec:
        @rpath/sqlitevec.framework/sqlitevec (compatibility version 0.0.0, current version 0.0.0)
        /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1351.0.0)
</code></pre>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Apple has terribly messed with dynamic library loading in iOS, has diverged from the unix standard. This was an absolute pain to get right, so I hope I will save someone some time in case you ever need to compile a dylib for iOS.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">React Native RCTRootViewFactory (Brownfield apps)</title><link href="https://ospfranco.com/react-native-rctrootviewfactory/" rel="alternate" type="text/html" title="React Native RCTRootViewFactory (Brownfield apps)" /><published>2025-01-21T00:00:00+09:00</published><updated>2025-01-21T00:00:00+09:00</updated><id>https://ospfranco.com/react%20native%20rctrootviewfactory</id><content type="html" xml:base="https://ospfranco.com/react-native-rctrootviewfactory/"><![CDATA[<p>As I was upgrading one of my RN macOS projects I was having crashes when bumping to the latest version of RN. My app is heavily customized and uses a brownfield approach. The view which hosts React Native is not the entry point of the app, but rather I manually create it an load it into an NSPanel.</p>

<p>There has been a lot of changes with the new architecture of React Native and a class <code>RCTRootViewFactory</code> has been introduced to help brownfield apps having to initialize a bunch of internal objects. However, there is a lack of documentation.</p>

<p>The base class was contributed by Oskar and <a href="https://x.com/o_kwasniewski/status/1764971481778323529">announced on twitter</a>, there is also this <a href="https://www.callstack.com/blog/simplify-your-ios-brownfield-integration-with-rootviewfactory">callstack article</a>, but both are a bit incomplete or not indexable</p>

<p>I’ll just dump you the code right here (for a Swift entry point)</p>

<pre><code class="language-swift">import Foundation
import React_RCTAppDelegate

// Inhering from RCTAppDelegate instead of NSAppDelegate and/or NSObject
@NSApplicationMain
@objc
class AppDelegate: RCTAppDelegate {
  override func sourceURL(for bridge: RCTBridge) -&gt; URL? {
    self.bundleURL()
  }

  override func bundleURL() -&gt; URL? {
    #if DEBUG
      RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
    #else
      Bundle.main.url(forResource: "main", withExtension: "jsbundle")
    #endif
  }

  // Use this one to customize the rootview before it is returned
  override func customize(_ rootView: RCTRootView) {
    rootView.wantsLayer = true
    rootView.backgroundColor = .clear
    rootView.layer?.backgroundColor = .clear
  }


  // didFinishLaunching for macOS apps, for iOS it is slightly different (returns a BOOL) just overload the correct one
  override func applicationDidFinishLaunching(_ notification: Notification) {
    self.automaticallyLoadReactNativeWindow = false // Important to prevent RCTAppDelegate from trying to init the default RN View
    super.applicationDidFinishLaunching(notification) // Needs to be called on the latest versions to initialize all the internal RN variables and state

    let rootView = self.rootViewFactory.view(withModuleName: "[Your bundle name]") // Finally create a RN Hosting View`
    // add it to your NSWindow or HostingNSView
  }
}
</code></pre>

<p>The beauty of this abstraction is that it should be future proofed whenever the framework changes, preventing weird crashes and errors. If you turn on the flags you can do it programmatically from the constructor.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[As I was upgrading one of my RN macOS projects I was having crashes when bumping to the latest version of RN. My app is heavily customized and uses a brownfield approach. The view which hosts React Native is not the entry point of the app, but rather I manually create it an load it into an NSPanel.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Use React as a Rendering Layer</title><link href="https://ospfranco.com/use-react-as-a-rendering-layer/" rel="alternate" type="text/html" title="Use React as a Rendering Layer" /><published>2024-11-11T00:00:00+09:00</published><updated>2024-11-11T00:00:00+09:00</updated><id>https://ospfranco.com/use%20react%20as%20a%20rendering%20layer</id><content type="html" xml:base="https://ospfranco.com/use-react-as-a-rendering-layer/"><![CDATA[<p>A couple of tweets caught my eye this week:</p>

<p>[Kitze tweet]</p>

<p>[Tweet about dan leaving twitter]</p>

<p>I have tweeted extensively in the past how React state management is too complex and easy to get wrong. The fact that one has to read long threads of tweets to getting some amount of understanding of how to operate it just speaks volumes.</p>

<h1 id="render-cycles-is-a-bad-state-update-mechanism">Render cycles is a bad state update mechanism</h1>

<p>At the core of the problem lies the fact that React is a UI library. Being a UI library it first concern was to render state efficiently. To render state efficiently it came up to render cycles. Change your state, your component re-renders itself (and its children). As the library matured, we’ve migrated from classes to hooks. It’s hard to decompose the problem, but it boils down to state-updates now ticks at the rythm of the render cycles:</p>

<ul>
  <li>Render</li>
  <li>Update variable</li>
  <li>Trigger re-render</li>
  <li>Trigger useEffect</li>
  <li>Potentially update variable</li>
  <li>Trigger re-render</li>
</ul>

<p>We have fallen in this cycle, where every variable change (state update) is now thought in terms of React renders. And this is a hard, complex and non-sensical way of programming. Because, everything depends on everything. It quickly explodes in complexity. You have to prevent re-renders (useMemo), try to avoid function re-creation (useCallback) while at the same time triggering side-effecty code (useEffect). This also triggers re-renderings on large parts of the UI as the prop comparisson is naive. Comically enough, React doesn’t properly react to changes, at least not smart enough. The so-called React compiler is an implicit acceptance that this model is fundamentally broken and we know need to statically analyse code to get untangle this mess.</p>

<h1 id="way-out">Way out</h1>

<p>I could ramble more and more but there is no point. If you live through the pain of maintaining a mid to large React app with lots of hooks and contexts this problem is self evident. So here is one way out: use mobx.</p>

<p>Mobx bring sanity to state management by using a simple observer pattern. You modify a variable, things that use the variable get re-rendered. As simple as that. Not even entire trees of things get re-render, JUST THE THINGS THAT USE IT. This means no more <code>useMemo</code>.</p>

<p>You can declare model classes once, this contains variables (<code>useState</code>), functions declared once (meaning no more <code>useCallback</code>) and calculated values. Side-effects are no longer a weird <code>useEffect</code> with a list of variables that might affect it, code can just be triggered when variables are set. Some times it might be a more code duplication, but it’s no longer React programming, it’s just programming.</p>

<p>It has some quirks, like having to use <code>runInAction</code> after using <code>await</code> but the trade-off is more than worthy. Your React code is just a rendering layer. NO HOOKS, NO CONTEXT. React excels at manipulating the DOM and giving you a re-usable abstraction, let it do just that.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[A couple of tweets caught my eye this week:]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Make MISE installed tools globally available for GUI tools</title><link href="https://ospfranco.com/make-mise-installed-tools-globally-available-for-gui-tools/" rel="alternate" type="text/html" title="Make MISE installed tools globally available for GUI tools" /><published>2024-09-23T00:00:00+09:00</published><updated>2024-09-23T00:00:00+09:00</updated><id>https://ospfranco.com/make%20mise%20installed%20tools%20globally%20available%20for%20gui%20tools</id><content type="html" xml:base="https://ospfranco.com/make-mise-installed-tools-globally-available-for-gui-tools/"><![CDATA[<p>I’m a very big fan of <a href="https://mise.jdx.dev">Mise</a>. It allows me to quickly swap and install system tools in my macOS machine. Node, Ruby, Python, JDKs, etc. Instead of doing installations that can permanently change the OS and are not easy to revert (even with Homebrew), Mise handles all multiple installations on a per folder level.</p>

<p>I usually set a global version for the most common tools I use, one of them being Node:</p>

<pre><code>mise global node@20
</code></pre>

<p>This works perfectly when I run the commands from the terminal. However, the problem comes with GUI apps such as Android Studio or Xcode. This apps do not execute binaries from a terminal session (at least not a sandboxed one). So one has to make the installed tools available to them. One way that works for single binaries (e.g. node) is to create a symlink:</p>

<pre><code>sudo ln -s $(which node) /usr/local/bin
</code></pre>

<p>However, this breaks down when one has to link a binary that might depend on a relative structure import. One example is npx:</p>

<pre><code>sudo ln -s $(which npx) /usr/local/bin
</code></pre>

<p>Will throw an error whenever the GUI program tries to execute an <code>npx</code> command. Because <code>npx</code> is just a JS script that calls <code>npm</code> internally, however it relies on a relative import:</p>

<pre><code>#!/usr/bin/env node

const cli = require('../lib/cli.js')

// run the resulting command as `npm exec ...args`
process.argv[1] = require.resolve('./npm-cli.js')
process.argv.splice(2, 0, 'exec')

// ... the rest of the npx script
</code></pre>

<h1 id="create-a-wrapper-script">Create a wrapper script</h1>

<p>In order to solve this issue, create a wrapper script in <code>/usr/local/bin</code>. The reason to place it there is because most apps default to known locations (without the chance for you to modify the PATH, e.g. Xcode).</p>

<pre><code>sudo touch /usr/local/bin/npx
</code></pre>

<p>then:</p>

<pre><code>#!/bin/bash
NODE_BASE_DIR="/Users/osp/.local/share/mise/installs/node/20/bin"
exec "$NODE_BASE_DIR/npx" "$@"%
</code></pre>

<p>After creating it give it execute permissions:</p>

<pre><code>sudo chmod a+x /usr/local/bin/npx
</code></pre>

<p>You might need to restart your program or computer for the binary to be correctly found. This should also work for any other scripts binaries you might have an issue. If you are worried about modifying <code>/usr/local/bin</code> don’t be. It’s a per user folder where symlinks and binaries can be placed. Lots of programs add links to their binaries here to make them globally available to other GUI tools: VSCode, Parallels, etc.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I’m a very big fan of Mise. It allows me to quickly swap and install system tools in my macOS machine. Node, Ruby, Python, JDKs, etc. Instead of doing installations that can permanently change the OS and are not easy to revert (even with Homebrew), Mise handles all multiple installations on a per folder level.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Compiling OpenSSL in Rust for Android</title><link href="https://ospfranco.com/compiling-openssl-in-rust-for-android/" rel="alternate" type="text/html" title="Compiling OpenSSL in Rust for Android" /><published>2024-09-21T00:00:00+09:00</published><updated>2024-09-21T00:00:00+09:00</updated><id>https://ospfranco.com/compiling%20openssl%20in%20rust%20for%20android</id><content type="html" xml:base="https://ospfranco.com/compiling-openssl-in-rust-for-android/"><![CDATA[<p>There is now a long standing issue with the latest versions of OpenSSL. <a href="https://github.com/openssl/openssl/pull/22181">The handwritten assembly is incompatible with Position Independent Code</a>. While this issue is not resolved it means the latest versions of OpenSSL do not run on Android.</p>

<p>As a side note, the NDK port of <a href="https://github.com/android/ndk/issues/1992">OpenSSL is still on version 1.1.1 which is EOL</a>. This is a huge vunerability for Android but it seems the NDK team has no priority on updating this.</p>

<p>In a client project I’m using Rust which depends on OpenSSL. This has left me no choice other than to patch OpenSSL myself, so I get it to compile to Android platforms.</p>

<h1 id="compiling-openssl">Compiling OpenSSL</h1>

<p>Here is a script that will download and compile OpenSSL for Android directly. It already includes the patching described in the GitHub issue to patch the handcrafted assembly.</p>

<pre><code class="language-bash">#!/bin/bash

# Clone or download the sources (it's done for you at below)
# You should most definitely read the ANDROID notes to see the exact command. A lot of the scripts online are outdated for the 1.X branches
# You basically need to set the ANDROID_NDK_HOME variable for this script to work
# Generating the dylibs was failing for me, so disabled it for now

#set -v
set -ex

export OPENSSL_VERSION="openssl-3.3.2"
rm -rf ${OPENSSL_VERSION}
# Sometimes this link breaks, you can manually download the sources yourself
# curl -O "https://github.com/openssl/openssl/releases/download/${OPENSSL_VERSION}/${OPENSSL_VERSION}.tar.gz"
tar xfz "${OPENSSL_VERSION}.tar.gz"

PROJECT_HOME=`pwd`
PATH_ORG=$PATH
OUTPUT_DIR="libs"

# Clean output:
rm -rf $OUTPUT_DIR
mkdir $OUTPUT_DIR

build_android_clang() {

	echo ""
	echo "----- Build libcrypto &amp; libssl.so for "$1" -----"
	echo ""

	ARCHITECTURE=$1
	TOOLCHAIN=$2
	stl="libc++"

	# Set toolchain
	export TOOLCHAIN_ROOT=$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/darwin-x86_64
	export SYSROOT=$TOOLCHAIN_ROOT/sysroot
	export CC=${TOOLCHAIN}21-clang
	export CXX=${TOOLCHAIN}21-clang++
	export CXXFLAGS="-fPIC"
	export CPPFLAGS="-DANDROID -fPIC"

	export PATH=$TOOLCHAIN_ROOT/bin:$SYSROOT/usr/local/bin:$PATH

	cd "${OPENSSL_VERSION}"

	./Configure $ARCHITECTURE no-asm no-shared -D__ANDROID_API__=21

	make clean
	# Apply patch that fixes the armcap instruction
	# Linux version
	# sed -e '/[.]hidden.*OPENSSL_armcap_P/d; /[.]extern.*OPENSSL_armcap_P/ {p; s/extern/hidden/ }' -i -- crypto/*arm*pl crypto/*/asm/*arm*pl
	# macOS version
	sed -E -i '' -e '/[.]hidden.*OPENSSL_armcap_P/d' -e '/[.]extern.*OPENSSL_armcap_P/ {p; s/extern/hidden/; }' crypto/*arm*pl crypto/*/asm/*arm*pl

	make

	mkdir -p ../$OUTPUT_DIR/${ARCHITECTURE}/lib
	mkdir -p ../$OUTPUT_DIR/${ARCHITECTURE}/include

	cp libcrypto.a ../$OUTPUT_DIR/${ARCHITECTURE}/lib/libcrypto.a
	cp libssl.a ../$OUTPUT_DIR/${ARCHITECTURE}/lib/libssl.a

	cp -R include/openssl ../$OUTPUT_DIR/${ARCHITECTURE}/include

	cd ..
}

build_android_clang "android-arm" "armv7a-linux-androideabi"
build_android_clang "android-x86" "i686-linux-android"
build_android_clang "android-x86_64" "x86_64-linux-android"
build_android_clang "android-arm64" "aarch64-linux-android"
</code></pre>

<p>This script will create a <code>libs</code> folder, which contains all the files in the necessary structure.</p>

<h1 id="compiling-rust-crate">Compiling Rust crate</h1>

<p>In order to compile this in your Rust crate you need to first add the crates:</p>

<pre><code class="language-toml">openssl = "0.10"
openssl-sys = "0.9.103"
</code></pre>

<p><code>openssl</code> is a bindings crate for the Rust code, but the openssl-sys takes care of compiling/detecting OpenSSL itself.</p>

<p>With this crates added, we can then invoke the compilation command with an added flag <code>OPENSSL_DIR</code> which <code>openssl-sys</code> will detect and instead of compiling OpenSSL from source will use the precompiled static libraries we generated.</p>

<p>Here I’m using <code>cargo-ndk</code> which is a crate that does the SDK/NDK discovery for you so you can easily compile for android. This is a <code>Makefile</code> version, but you can use whatever you want to point to it to the correct folder that matches the architecture:</p>

<pre><code class="language-make">android-build-release-%:
	@ if [ "$*" = "aarch64-linux-android" ]; then \
			OPENSSL_DIR=$(CURDIR)/libs/android-arm64; \
	  elif [ "$*" = "x86_64-linux-android" ]; then \
	    OPENSSL_DIR=$(CURDIR)/libs/android-x86_64; \
	  elif [ "$*" = "armv7-linux-androideabi" ]; then \
	    OPENSSL_DIR=$(CURDIR)/libs/android-arm; \
	  elif [ "$*" = "i686-linux-android" ]; then \
	    OPENSSL_DIR=$(CURDIR)/libs/android-x86; \
	  else \
	    echo "Unknown target: $*"; \
	    exit 1; \
	  fi; \
	  OPENSSL_DIR=$$OPENSSL_DIR cargo ndk --target $* --platform 31 build --release --all-features
</code></pre>

<p>Once everything is ready, will not only the Android binary be correct, you will actually be using the latest version of OpenSSL instead of the outdated NDK ports.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[There is now a long standing issue with the latest versions of OpenSSL. The handwritten assembly is incompatible with Position Independent Code. While this issue is not resolved it means the latest versions of OpenSSL do not run on Android.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">App clip with React Native and New Arch (and Swift)</title><link href="https://ospfranco.com/app-clip-with-react-native-and-new-arch-(and-swift)/" rel="alternate" type="text/html" title="App clip with React Native and New Arch (and Swift)" /><published>2024-06-30T00:00:00+09:00</published><updated>2024-06-30T00:00:00+09:00</updated><id>https://ospfranco.com/app%20clip%20with%20react%20native%20and%20new%20arch%20(and%20swift)</id><content type="html" xml:base="https://ospfranco.com/app-clip-with-react-native-and-new-arch-(and-swift)/"><![CDATA[<p>I had to create an App Clip for a project using React Native. There are people who have done it before, but info is now outdated so posting an updated guide.</p>

<p>Most of the steps come from this <a href="https://github.com/codibly/app-clip-instant-app-react-native/blob/main/Creating-React-Native-AppClip.md">repo</a> kudos to codibly and also all the amazing people that provide all the packages and guides for integrations between old-arch and new-arch.</p>

<ul>
  <li>Add a new target to your project. Select Swift and StoryBoard.</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip1.jpg" alt="appclip1" /></p>

<ul>
  <li>Add the <code>@rnx-kit/react-native-host</code>. It’s a package that allows to hoist a RCTRootView in the different architectures</li>
</ul>

<pre><code class="language-sh">yarn add @rnx-kit/react-native-host --dev
</code></pre>

<ul>
  <li>Modify your <code>podfile</code></li>
</ul>

<pre><code class="language-ruby">  # In your main app target add the following

  # Auto linking is broken on this package
  # https://github.com/microsoft/rnx-kit/issues/3208
  pod 'ReactNativeHost', :path =&gt; "../node_modules/@rnx-kit/react-native-host"

  target 'Clip' do
    inherit! :complete
    # Pods for Clip
  end
</code></pre>

<ul>
  <li>Do a new arch pod install</li>
</ul>

<pre><code class="language-sh">cd ios &amp;&amp; RCT_NEW_ARCH_ENABLED=1 pod install
</code></pre>

<ul>
  <li>Create a <code>BridgeManager.swift</code> class in the Clip target. Make sure it is added to the correct target! This class will help us instantiate a “host” which is compatible with the old arch and new arch.</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip2.jpg" alt="appclip2" /></p>

<pre><code class="language-swift">import Foundation
import React
import ReactNativeHost

class BridgeManager: NSObject {
    static let shared = BridgeManager()

    var host: ReactNativeHost?

    public func loadReactNative(launchOptions: [AnyHashable: Any]?) {
      host = ReactNativeHost(self)
    }
}

extension BridgeManager: RNXHostConfig {
  func sourceURL(for bridge: RCTBridge) -&gt; URL? {
        #if DEBUG
          return RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index.clip")
        #else
            return Bundle.main.url(forResource: "main", withExtension: "jsbundle")
        #endif
    }
}
</code></pre>

<p>In order for the DEBUG preprocessor macro to run, we need to add the DEBUG flag into the build settings of the Clip target</p>

<p><img src="https://ospfranco.com/assets/appclip5.jpg" alt="appclip5" /></p>

<ul>
  <li>We are going to modify the <code>AppDelegate.m</code> at the Clip target:</li>
</ul>

<pre><code class="language-swift">import React
import ReactNativeHost
import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate, RNXHostConfig {

  var window: UIWindow?

  func sourceURL(for bridge: RCTBridge) -&gt; URL? {
    return nil
  }

  func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -&gt; Bool {
    BridgeManager.shared.loadReactNative(launchOptions: launchOptions)
    // Override point for customization after application launch.
    return true
  }

  // MARK: UISceneSession Lifecycle

  func application(
    _ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession,
    options: UIScene.ConnectionOptions
  ) -&gt; UISceneConfiguration {
    // Called when a new scene session is being created.
    // Use this method to select a configuration to create the new scene with.
    return UISceneConfiguration(
      name: "Default Configuration", sessionRole: connectingSceneSession.role)
  }

  func application(
    _ application: UIApplication, didDiscardSceneSessions sceneSessions: Set&lt;UISceneSession&gt;
  ) {
    // Called when the user discards a scene session.
    // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
    // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
  }
}
</code></pre>

<ul>
  <li>We can the finally load the <code>RCTRootView</code> (the view that holds RN) into the app clip controller</li>
</ul>

<pre><code class="language-swift">import UIKit
import ReactNativeHost

class ViewController: UIViewController {

  override func loadView() {
    if let host = BridgeManager.shared.host {
          self.view = host.view(
              moduleName: "clip",
              initialProperties: nil
          )
      }

  }

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
    }


}
</code></pre>

<ul>
  <li>At this point you should get the gist of what we are trying to do. Start a RN instance inside the App Clip. However, we now need to take care of a bunch of minutia that is annoying. We are going to copy the contents of the main target <code>Bundle React Native code and images</code> but modify it so that instead of loading the <code>index.js</code> file it loads <code>index.clip.js</code>. Go to build phases, add new script and copy the contents of the script:</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip3.jpg" alt="appclip3" /></p>

<pre><code class="language-sh">set -e

WITH_ENVIRONMENT="$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh"
REACT_NATIVE_XCODE="$REACT_NATIVE_PATH/scripts/react-native-xcode.sh"

/bin/sh -c "ENTRY_FILE=index.clip.js $WITH_ENVIRONMENT $REACT_NATIVE_XCODE"
</code></pre>

<ul>
  <li>We are going to run into a hermes error. You need to disable <code>User Script Sandboxing</code> on the build settings of the clip target:</li>
</ul>

<p><img src="https://ospfranco.com/assets/appclip4.jpg" alt="appclip4" /></p>

<ul>
  <li>We can finally create our <code>index.clip.js</code> at the root of the project</li>
</ul>

<pre><code class="language-js">import React from "react";
import { AppRegistry, View, Text } from "react-native";

const AppClip = () =&gt; (
  &lt;View&gt;
    &lt;Text&gt;Hello,&lt;/Text&gt;
    &lt;Text&gt;I'm your AppClip!&lt;/Text&gt;
  &lt;/View&gt;
);

AppRegistry.registerComponent("clip", () =&gt; AppClip);
</code></pre>

<p>Notice we are registering the component as <code>clip</code> which matches the component being loaded at the ViewController.</p>

<p>That’s it, if everything is configured correctly you should be able to see your app clip loaded. You can find the repo of this app <a href="https://github.com/ospfranco/RNAppClip">here</a></p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[I had to create an App Clip for a project using React Native. There are people who have done it before, but info is now outdated so posting an updated guide.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Client guide to React Native modules</title><link href="https://ospfranco.com/client-guide-to-react-native-modules/" rel="alternate" type="text/html" title="Client guide to React Native modules" /><published>2024-06-25T00:00:00+09:00</published><updated>2024-06-25T00:00:00+09:00</updated><id>https://ospfranco.com/client%20guide%20to%20react%20native%20modules</id><content type="html" xml:base="https://ospfranco.com/client-guide-to-react-native-modules/"><![CDATA[<p>Let’s play the following scenario: You are my client and I’m me. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this <code>JSI</code>/<code>Turbo Module</code>/<code>new arch</code> stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article.</p>

<blockquote>
  <p>If you are a RN dev you can skip this, this is an overview of React Native modules meant for people not in the React Native ecosystem. No new information or in-depth technical knowledge is here, just enough for adjacent people can get a grip of the terminology</p>
</blockquote>

<h1 id="old-arch">Old arch</h1>

<p>How do you pass data between JavaScript, a interpreted language that runs on C++ to native runtimes of iOS (Swift/ObjC) and Android (Java/Kotlin)? easy! JSON. You serialize your data and every native function that you need to call can pass through a narrow tube of message passing. This is what we call the <code>old arch</code> (the usage of JSON message passing is also called the <code>bridge</code>) of React Native.</p>

<h2 id="pros">Pros</h2>

<ul>
  <li>It is easy to create modules with it. Due to the ease of marking methods and the runtime registration, there is not a lot of setup necessary.</li>
  <li>❗ Old modules are still supported in the <code>new arch</code> (we will talk about it in a bit). In fact there has been a special work put onto them so that they remain compatible at least for extra year while libraries and apps migrate to the new arch.</li>
  <li>If your SDK sends a small amount of data, actually should be more than enough for your needs.</li>
  <li>⭐ If you use <code>bridgeless</code> (will talk about it in a second), they are as fast as <code>new arch</code> modules.</li>
</ul>

<h2 id="cons">Cons</h2>

<ul>
  <li>It is slow and can get stuck when there is a large amount of data being serialized between the JS code and the native runtimes.</li>
  <li>It’s being phased out</li>
</ul>

<h1 id="new-arch">New arch</h1>

<p>React Native used to have a bad reputation for having bad performance. In order to solve this, one of the key problems was the JSON bridge. So a bunch of concepts/modules/ideas where introduced. The conjunction of the following terms form what is called <code>new arch</code>:</p>

<h2 id="jsi">JSI</h2>

<p>The first thing to solve is the slow passing data between JS and native. To fix this, the JavaScript Interface = <code>JSI</code>. It’s basically a bunch of C++ functions that allow to interact with JavaScript from C++ without paying for serialization costs of JSON. You can think of it as Node-API (NodeJS protocol to call native code) but a bit shittier since it is not a binary communication protocol but rather a bolt-on with some higher costs.</p>

<p>The problem when interacting with C++ code though is that it introduces a gap between JS and native. Whenever you run JS code it runs on a JavaScript engine (JavaScript Core or Hermes in React Native’s case), but actually one should think about this “context” as a virtual machine (my own words). It is a VM that can be instantiated multiple times, though your UI will run on just one of them. Multiple JS VMs are how <code>Web Workers</code> (though they are not available in RN) and certain level of parallelism in JavaScript is achieved. It reads your JS and keeps a internal state of the code it runs, has it’s own heap and can die out. Most importantly, you cannot just fiddle with it while is interpreting your JS. The functions provided by <code>JSI</code>, allow to do work with this virtual machine/context/runtime by allowing to enqueue callbacks, cast JS values into C++ values, etc.</p>

<p><code>JSI</code> is the corner stone of the new arch.</p>

<h2 id="fabric">Fabric</h2>

<p>Forget about fabric, it’s about how UI components are rendered using the <code>JSI</code> and it’s mostly internal. It will have very little influence on your module, with the exception on how your UI components are registered.</p>

<h2 id="bridgeless">Bridgeless</h2>

<p>It’s just a configuration flag that completely removes the JSON bridge. <code>old arch</code> modules will still work (in fact they will use the JSI too). It’s just part of the migration to kill the old bridge once and for all.</p>

<h1 id="turbo-modules">Turbo Modules</h1>

<p>All the internals of RN started to migrate from JSON to interacting with C++. So we now need a new way to create native modules for React Native. Turbo Modules are a solution to this problem. Is it important to know: <code>Turbo Modules</code> are <strong>built</strong> on top of <code>JSI</code>. You can have <code>new arch</code> modules (that use the JSI) without Turbo Modules, but not the other way around. <code>Turbo Modules</code> take a Typescript or Flow file, and then with a ungodly amount of JavaScript generate a bunch of C++ code, which React Native then includes in your project. They are also a DSL of TypeScript/Flow (😥).</p>

<blockquote>
  <p><code>Turbo Modules</code> are <strong>built on top</strong> of the <code>JSI</code></p>
</blockquote>

<h2 id="pros-1">Pros</h2>

<ul>
  <li>Lazy initialization</li>
  <li>Much faster runtime performance</li>
  <li>Synchronized function definitions between JS and native</li>
</ul>

<h2 id="cons-1">Cons</h2>

<ul>
  <li>Much more harder to setup</li>
  <li>Lack of documentation</li>
  <li>Require C++ knowledge and good knowledge of the internals of RN if you deviate from the golden path</li>
</ul>

<h1 id="expo-modules">Expo modules</h1>

<p><code>Turbo Modules</code> and the necessary knowledge to make use of <code>JSI</code> is not trivial at all. It requires knowledge of C++, ObjC, Kotlin/Java, Java’s JNI, the build systems and knowledge of the internals of RN. The great guys at expo saw from a mile away that for a company/team building an app in React Native, it is pretty much an impossible task to learn how to code all of these by themselves. Therefore they also applied ungodly amounts of Kotlin/Swift magic and created their own module system.</p>

<h2 id="pros-2">Pros</h2>

<ul>
  <li>Much more easier to expose native (Swift/Kotlin) functions to JS</li>
  <li>They still use the JSI, so they are quite fast</li>
  <li>Much easier to create and move around</li>
</ul>

<h2 id="cons-2">Cons</h2>

<ul>
  <li><strong>Only run on expo apps</strong></li>
  <li>JSI is C++, Expo Modules are Swift/Kotlin, so <strong>there is</strong> a runtime performance cost. It’s not nothing, might or might not be critical depending on your module. I posted benchmarks in my Twitter.</li>
  <li>The signatures of functions need to be adjusted manually between native and the JS side</li>
</ul>

<h1 id="c-turbo-modules">C++ Turbo Modules</h1>

<p>It’s notable to mention that there are a lot of cases where you don’t want to interact with the native languages (Swift/Kotlin) but you might want to do pure C++ bindings. For some libraries like <code>sqlite</code>, <code>libsql</code>, Rust modules. This is what you want. The <code>JSI</code> is C++, your code is C(++). This will be the fastest option in terms of runtime cost, but documentation is super scant, outdated. They are also tricky to setup.</p>

<h1 id="which-should-you-pick">Which should you pick?</h1>

<p>It depends.</p>

<p>You have a small team and want to just call some native Swift/Kotlin and are running Expo already: go for Expo Modules.</p>

<p>You have a C/C++/Rust library and require the most amount of performance: Go for C++ Turbo Module or a custom JSI module.</p>

<p>You want JSI, have some expertise, not on expo: go for Turbo Modules, documentation is scant so this is the least option I recommend</p>

<p>You want to get the ball rolling for now: go for an old arch module</p>

<h1 id="qa">QA</h1>

<p><strong>Q</strong>: Is it possible to have a <code>new arch</code> (i.e. Turbo Module) that is compatible with <code>old arch</code>?</p>

<p><strong>A</strong>: Yes, but it’s terrible, it takes a lot of work, copying the generated files and modifying the compilation process so that everything runs on both archs. You will definitely need help from one of the agencies or me to get this working properly and maintain it.</p>

<p><strong>Q</strong>: Do you like Turbo Modules</p>

<p><strong>A</strong>: I don’t, they are tricky to setup with code generation step and cryptic native errors. I would much rather stick to pure C++ modules. Also, codegen sucks, never do codegen.</p>

<p><strong>Q</strong>: But Expo [insert your comment here]</p>

<p><strong>A</strong>: Expo Modules are great if they work for you. Use them. It’s fine. Go ask them for issues.</p>

<p><strong>Q</strong>: You say <code>JSI</code> is C++, how come <code>Turbo Modules</code> are ObjC/Kotlin/Java?</p>

<p><strong>A</strong>: The same way Expo Modules are Swift/Kotlin. Ungodly amount of jumping between languages. Swift → ObjC++ → C++. Kotlin/Java → <code>JNI</code> (which is SLOW) → C++. You might be returning native objects/scalars when writing your code, but there is a lot of work later to cast stuff all the way to the right C++ abstractions.</p>

<p><strong>Q</strong>: Can I write my Turbo Module in Swift?</p>

<p><strong>A</strong>: No (kinda). Latest versions of Swift (5.9+) improved compatibility with C++, but it still ways to go. The codegen scripts and all the internal tooling works with ObjC. You can write a very thin ObjC façade that will call your Swift code. So yes, there is a way to make it work but it’s not straightforward.</p>

<p><strong>Q</strong>: When will I be able to write my <code>Turbo Module</code> in Swift?</p>

<p><strong>A</strong>: Some day… maybe never… go ask Meta very nicely to do this :)</p>

<p><strong>Q</strong>: Can I write a native module in Rust?</p>

<p><strong>A</strong>: Yes, but not directly. Your Rust code needs to expose a C-ABI compatible API, which will then be called from a C++ turbo module, <a href="https://ospfranco.com/post/2024/05/08/react-native-rust-module-guide/">here is a guide</a>. There is also this <a href="https://github.com/laptou/jsi-rs">repo</a> in case you really want to write everything in rust, but I haven’t managed to get it to run, my Rust-Fu is not advanced enough, but it seems to bridge all the JSI code into Rust so you can call all the functions directly from Rust.</p>

<p><strong>Q</strong>: What are the pitfalls when writing my native module?</p>

<p><strong>A</strong>: There are many, for example you cannot just invoke a JSI/JS function in the middle of your native code. The JS VM might be busy doing something else, if you all of the sudden ask it to allocate memory for a JS object for example, you might corrupt the stack and your entire thing will go kaput. In order to get this you need to schedule a callback using a call invoker, then await on your native code, etc etc. It’s complex to get all of the moving parts working nicely.</p>]]></content><author><name>Oscar Franco</name></author><category term="post" /><summary type="html"><![CDATA[Let’s play the following scenario: You are my client and I’m me. You ask “Oscar, we want to port our SDK/Library/module to React Native, but all this JSI/Turbo Module/new arch stuff is confusing, can you help us?” the answer dear client is obviously yes. However, I’m a bit tired of explaining the same concepts again and again, so I will point you to this article.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ospfranco.com/assets/oscar.jpg" /><media:content medium="image" url="https://ospfranco.com/assets/oscar.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>