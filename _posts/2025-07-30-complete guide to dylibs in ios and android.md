---
layout: post
title: Complete guide to (Rust) dylibs in iOS and Android
date: 2025-07-30
categories: post
permalink: /:title/
image: /assets/oscar.jpg
---

In 2025 loading a dynamic library in iOS and Android is black magic. Documentation is scarce (specially on Apple's side) yet a dylib is great for reducing file sizes of our binaries, which is a priority for mobile apps.

This is a complete guide compiling a Rust library from source all the way into loading it in a running iOS/Android application. All done via C compatible dylib, which means on iOS you will need to call if from Obj-C and on Android via JNI.

# Dylib?

First a dylib is great, because unlike a static library, it doesn't package the whole world when it comes to the code it needs to run. In my project on iOS the resulting binary went from 32Mbs to 10Mbs on iOS and from 57Mbs to 13Mbs(!) on Android. You can read more on why static linking is, although a very functional solution, [kinda sucks](https://medium.com/@eyal.itkin/the-a-file-is-a-relic-why-static-archives-were-a-bad-idea-all-along-8cd1cf6310c5).

# Rust

We will start with a Rust crate and we will generate a dylib out of it.

Init a basic create with the --lib template. You can then expose a C function that you will be able to call from your iOS Obj-C/Kotlin via JNI code.

```rust
// lib.rs
#[no_mangle]
pub extern "C" fn get_answer() -> i32 {
  42
}
```

Next on the `Cargo.toml`, we will declare the crate type as `cdylib`. the `cdylib` assumes that libc will be available on the target you are compiling to, so it will produce even smaller binaries. We will also add some flags to the release compilation profile to generate even smaller binaries:

```toml
[profile.release]
strip = "symbols"
lto = true
opt-level = "z"
codegen-units = 1

[lib]
crate-type = ["cdylib"]
```

Now, you will need to compile your crate for both iOS and Android. For iOS is mostly straight forward since you are compiling on a Mac (you need a mac anyways to compile iOS apps):

```bash
cargo build --lib --release --target aarch64-apple-ios
```

For Android one needs to set up a lot of variables pointing to the correct android libraries, headers and compilers. It's all a PITA to be honest, so we are not going to bother with that, and instead rely on `cargo-ndk` a package that handles the correct paths for us. Read the [README](https://github.com/bbqsrc/cargo-ndk), set up the necessary variables and you should be able to do:

```bash
cargo ndk --target aarch64-linux-android --platform=31 build --lib
```

That's the simple version of it. As your library grows and depends on other compilation steps you will need to modify your commands accordingly. Maybe setting a sysroot. Passing header files, setting up compiler files, etc.

If you compile your crate in your `target/{arch}` directories you should find a `.dylib` for iOS and a `.so` for Android. Going to skip some steps here for the sake of brevity, buy you should set `cbindgen` in your project along with a `build.rs` that generates a header file `.h` for your crates C (`lib.rs`) functions. The `rustc-link-arg` will be explained later.

```rust
extern crate cbindgen;

use std::env;

fn generate_c_headers() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let header_path = "../generated/include/mylib.h";

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_autogen_warning(
            "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */",
        )
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(header_path);
}

fn main() {
    // Tell Cargo that if the given file changes, to rerun this build script.
    println!("cargo:rerun-if-changed=src/lib.rs");

    // Tell cargo to dynamically link the C function we defined
    let target_os = env::var("CARGO_CFG_TARGET_OS").unwrap();

    match target_os.as_str() {
        "ios" => {
            println!("cargo:rustc-link-arg=-undefined");
            println!("cargo:rustc-link-arg=dynamic_lookup");
        }
        "android" => {
            println!("cargo:rustc-link-arg=-Wl,--allow-shlib-undefined");
        }
        _ => {}
    }

    generate_c_headers();
}

```

You will need to compile this binary for all the architectures your app supports, typical for mobiles will be:

`aarch64-apple-ios`
`aarch64-apple-ios-sim`
`x86_64-apple-ios-sim`
`aarch64-linux-android`
`armv7-linux-androideabi`
`x86_64-linux-android`
`i686-linux-android`

That's it for the native side of things, even if you are using other language like C, once you have those files correctly compiled plus your header file, it's time to move to the OS specific setup.

# iOS

Going to start with iOS as it is the most PITA out of the platforms. There is very little information out on how to load dylibs, not only that, unlike macOS and other unix derivations, it is not possible to just load them but they need to be packaged in a `.xcframework` that contains several `.framework`s... it's confusing and unnecessary.

[This part is taken from a previous article about package dylibs for iOS](https://ospfranco.com/generating-a-xcframework-with-dylibs-for-ios/)

1. Once these files are generated we need to merge the arm-simulator and intel-simulator binaries into a single "fat" binary. The reason is clashing of architectures (both arm-sim and intel-sim target the same "arch" so they clash and need to be merged into a "fat" binary). iOS dylibs **HAVE NO EXTENSION**.

```bash
# Where ${profile} is the profile you are compiling
lipo -create target/x86_64-apple-ios/${profile}/mylib.dylib target/aarch64-apple-ios-sim/${profile}/mylib.dylib -output generated/simulator_fat/mylib
```

2. With the binary merged we can drop everything into a `.xcframework` template. [You can download it here](https://github.com/OP-Engineering/op-sqlite/tree/main/ios/sqlitevec.xcframework). You need of course rename it properly and modify the paths but by using a template we skip more not-so-important steps.
   Copy the fat binary you just created into the `mylib.xcframework/ios-arm64_x86_64-simulator/mylib.framework` (after you have renamed the folders ofc, mylib is just a placeholder). Copy the `aarch64-apple-sim` version to the correct folder as well:

```bash
cp generated/simulator_fat/mylib mylib.xcframework/ios-arm64_x86_64-simulator/mylib.framework/
cp target/aarch64-apple-ios/${profile}/mylib.dylib mylib.xcframework/ios-arm64/mylib.framework/mylib
```

3. With the files in the correct places we need to final set the `@rpath`. The runtime path basically tells the OS where to find the canonical path of the file. It's mean for the runtime linker to find the correct file from a memory safe location when the app is compiled in hardened mode. This is confusing, don't think too much about it, it has to do with sand-boxing and security of the OS.

```bash
install_name_tool -id @rpath/mylib.framework/mylib mylib.xcframework/ios-arm64_x86_64-simulator/sdk.framework/mylib
install_name_tool -id @rpath/mylib.framework/mylib mylib.xcframework/ios-arm64/sdk.framework/mylib
```

## XCFramework

After you got your library compiled correctly, it's not enough to just drop them somewhere on iOS and call it a day. The `.xcframework` which basically is a folder that contains an `Info.plist`, tells Xcode/iOS which framework to load based on your computer arch and target. The `Info.plist` also contains entries to the folders which contain the `frameworks` that actually contain the dylibs.

## Each framework Info.plist

Each `.framework` inside the `.xcframework` contains it's own `Info.plist`. You can ignore most of this except the `CFBundleIdentifier` and `CFBundleExecutable`. These are important because they will be used on runtime to load the binary. You should modify them to match your library name and bundle identifier, modify both `Info.plist` files in the `.framework` folders:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>mylib</string> // MODIFY THIS
  <key>CFBundleIdentifier</key>
  <string>com.ospfranco.mylib</string> // MODIFY THIS
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0.0</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0.0</string>
	<key>MinimumOSVersion</key>
  <string>8.0</string>
</dict>
</plist>
```

## Including the files in the build

Here things will change a bit if you are directly adding the `.xcframework` into your project or if you are creating a library via cocoapods or SPM. In any case, you need to add your `mylib.h` header file (generated via `build.rs` and `cbindgen` remember?) and the `.xcframework` with the binaries.

### Directly into project

If you are integrating this dylib directly into your project. You can just drop the header file somewhere and import it directly in your `obj-c` code. The `.xcframework` you also add via Xcode UI and then add it as a dependency it via the UI in the general tab of your main target.

### Via Cocoapods

If you are using cocoapods you need to drop the header file and modify the paths cocoapods uses to include headers into the Pods, as well as specifying the `.xcframework`, in my case, I created a `include` folder in my source folder and dropped the header there:

```ruby
  # In the .podspec of your library
  s.public_header_files = 'include/**/*.h', 'src/objc/*.h'
  s.source_files = 'src/**/*', 'include/**/*.h'
  s.vendored_frameworks = 'mylib.xcframework'

  # Configure for dynamic library
  s.pod_target_xcconfig = {
    'OTHER_LDFLAGS' => '-undefined dynamic_lookup'
  }
```

Ignore the `OTHER_LDFLAGS` we will come back to them later.

### Via SPM

In SPM is a bit more obscure so something like this should work in your `Package.swift`:

```swift
 targets: [
    .binaryTarget(
      name: "mylib",
      path: "mylib.xcframework"
    ),
    .target(
      name: "MyWrapperLib",
      dependencies: ["mylib"],
      path: "src/objc",
      publicHeadersPath: ".",
      cSettings: [
        .headerSearchPath("../../include")
      ],
    ),
```

## Loading the dylib

Let's assume we are using Cocoapods. After doing a `pod install` the `.xcframework` should be included in our app, as well as our header file. In your Obj-C code you should be able to import the header file:

```objc
#import "mylib.h"
#import <dlfcn.h> // contains dlopen to load the dylib
```

But despite including the header file, it does not mean our library is loaded into the runtime. We need to use the `dlopen` function to do this. `dlopen` comes from the ancient times of unix, which basically tells iOS to load a dylib. Place this wherever you want to load your dylib:

```obj-c
  force_symbol_registration();

  NSBundle *dylib_bundle =
      [NSBundle bundleWithIdentifier:@"com.ospfranco.mylib"];
  NSString *dylib_path = [dylib_bundle pathForResource:@"mylib" ofType:@""];

  // Load the dynamic library
  void *handle = dlopen([dylib_path UTF8String], RTLD_NOW | RTLD_GLOBAL);
  if (!handle) {
    NSString *errorMessage = [NSString stringWithUTF8String:dlerror()];
  }
```

Broken down:

- dylib_bundle and dylib_path gets the runtime path of the appropriate binary for our arch. This is why we needed to set @rpath and modify the Info.plist in the `.framework` files
- We then call `dlopen` to load the library
- The `force_symbol_registration()` and `RTDL_GLOBAL` give the loaded library access to the global symbol table. Meaning your library can call C functions exposed by your iOS code. We will come back to this later.

In theory that's it, you should now be able to call the `get_answer` function from your Rust dylib!

```obj-c
#import "mylib.h"
#import <dlfcn.h>

// ...main()
{
  force_symbol_registration();

  NSBundle *dylib_bundle =
      [NSBundle bundleWithIdentifier:@"com.ospfranco.mylib"];
  NSString *dylib_path = [dylib_bundle pathForResource:@"mylib" ofType:@""];

  // Load the dynamic library
  void *handle = dlopen([dylib_path UTF8String], RTLD_NOW | RTLD_GLOBAL);
  if (!handle) {
    NSString *errorMessage = [NSString stringWithUTF8String:dlerror()];
  }

  int the_answer = get_answer();
}

```

# Android

Android luckily is basically just linux underneath, it's just `CMakeList` that is ancient technology and one needs to correct arcane commands to load a dylib.

## Place the files in the correct place

I'm going to skip certain parts as this post is long enough, but you basically need to drop the `.so` files you generated into `src/main/jniLibs` on per architecture folders if you are doing this as a library or `app/src/main/jniLibs` if doing it directly into your app. The header file you can drop in `src/main/jni/include` or `app/src/main/jni/include` respectively.

```
src
  main
    jni
      include
        mylib.h
    jniLibs
      arm64-v8a
        mylib.so
      armeabi-v7a
        mylib.so
      x86
        mylib.so
      x86_64
        mylib.so
```

The `jniLibs` folder is special and will be automatically picked up by Android in the compilation of the application. You can then follow any tutorial to set up JNI C++ code in your app/library. The only important point is linking our binary to the lib/app C++ code.

## Making CMake load the .so

In `CMakeLists.txt`:

```
cmake_minimum_required(VERSION 3.22.1)

project("MyJNIProject")

add_library(${CMAKE_PROJECT_NAME} SHARED
    MyJNIProject.cpp)

target_include_directories(${CMAKE_PROJECT_NAME} PUBLIC ${CMAKE_SOURCE_DIR}/../jni/include)

# Import the shared library but don't embed the absolute path
add_library(mylib SHARED IMPORTED)
set_target_properties(mylib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/mylib.so
    IMPORTED_NO_SONAME ON)

target_link_libraries(${CMAKE_PROJECT_NAME}
    mylib
    android)
```

Then in your Java/Kotlin code you just load the library created by CMakeLists which will in turn already have the `mylib.so` linked internally:

```kotlin
    init {
        System.loadLibrary("MyJNIProject")
    }
```

## Calling the code from JNI code

On your C++/JNI code you can just import the headers and call the functions you need

```C++
#include "mylib.h"

void main() {
  int the_answer = get_answer()
}
```

# Make native symbols available to Dylib

Here is a kicker. In the code above there have been some lines of code we have been omitting explaining what they do. Basically, without them, you can load your dylib and call it's functions, but your dylib cannot call functions in your app's code. This is particularly useful if you want to access some native functionality. You can write a extern "C" function that wraps some native iOS/Android api and call that from your Rust code.

## Rust

In rust we already added some `rustc` linker flags via `build.rs` that basically tell the Rust compiler to not panic if it cannot find a symbol. Since we are creating a dylib. The symbols will be there on runtime

```rust
    match target_os.as_str() {
        "ios" => {
            println!("cargo:rustc-link-arg=-undefined");
            println!("cargo:rustc-link-arg=dynamic_lookup");
        }
        "android" => {
            println!("cargo:rustc-link-arg=-Wl,--allow-shlib-undefined");
        }
        _ => {}
    }
```

## iOS

Let's define some C function:

```obj-c
// in the header file
OBJC_EXTERN void ios_prepare_request(const char *url);
```

The definition:

```obj-c
#define EXPORT __attribute__((visibility("default"), used)

EXPORT void ios_prepare_request(const char *url) {
  NSString *urlString = [NSString stringWithUTF8String:url];
  request =
      [NSMutableURLRequest requestWithURL:[NSURL URLWithString:urlString]];
}
```

In our Rust code, for iOS one can have in one (cfg'ed) file:

```rust
unsafe extern "C" {
    fn ios_prepare_request(url: *const c_char);
}
```

For android the equivalent:

```rust
unsafe extern "C" {
    fn android_prepare_request(url: *const c_char);
}

```

You can see this is super useful to expose functionality to our Rust code. In order to expose global symbols when using `dlopen` one passes the `RTDL_GLOBAL` flag:

```obj-c
void *handle = dlopen([dylib_path UTF8String], RTLD_NOW | RTLD_GLOBAL);
```

However, there is a problem, is that clang deletes away our function, since we are not using it in our native code, so code analysis just deletes since it cannot now that the dylib depends on that function, that's were the `force_symbol_registration` comes into play. It forces the compiler to keep our functions alive:

```obj-c
void force_symbol_registration() {
  // Force these symbols to be included in the binary by referencing them
  volatile void *ptrs[] = {(void *)ios_prepare_request};

  // Prevent compiler from optimizing away the array
  (void)ptrs;
}
```

## Android

Android is much easier, only adding the `IMPORTED_NO_SONAME` attribute when declaring our shared library already takes care of exposing the symbols:

```
set_target_properties(mylib PROPERTIES
    IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../jniLibs/${ANDROID_ABI}/mylib.so
    IMPORTED_NO_SONAME ON)
```

Whatever is declared in your C++/JNI code should be made available automatically to the Rust code.

# Conclusion

After all is done, not only have we loaded a dylib rust crate into iOS/Android, but also given the Rust code the ability to interact with native code (via wrapper C functions), which opens a world of possibilities.
